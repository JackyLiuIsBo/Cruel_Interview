# 阿里云一面凉经（？）

#### 项目的一些细节：

#### 高并发和性能测试的问题：

记得有问过我是否和主流的库作对比，有没有做过性能测试，怎么做性能测试

#### MySQL的底层数据结构？进一步问到B+树的性质，B+树的缺点

**MySQL索引类型有两种：**

1. hash索引（hashtable）

2. 非hash索引（底层是B+ 树）

**为什么非hash索引是B+树？**

1. AVL，红黑树等的结点对应一个索引，CPU每次至少从磁盘读取1页的数据，由于每个节点在内存中的位置是随机的，因此，很有可能CPU每次读取都只能得到一个索引的信息。 -> 没有利用好CPU与磁盘交互的特性

2. 每个节点只能有一个索引值，当数据量比较大的时候，或者顺序构建索引的时候，树高度会很大，从而成为性能的瓶颈

**B+树与B树对比，区别有哪些？**

1. B+树的父节点与子节点之间存在数据冗余

2. 正是因为父节点与子节点之间存在数据冗余，所以叶子节点包含了所有非叶子结点的值，并且每个数值从左到右按序排序

3. 叶子节点之间，从左到右都有一个指针进行连接，叶子节点之间是一个链表结构（mysql底层的B+树这个链表其实是双向链表）

**为什么选择B+树而不是B树？**

范围查找，B+树性能更优

**B+树的缺点？**

#### 智能指针有用过吗？他是怎么实现的？他是线程安全的吗？为什么？

> 多线程在操作一个共享数据的时候，保证所有线程的行为都是符合预期的

智能指针实现的代码就不说了，很长。依赖引用计数，RAII机制

智能指针的安全性不能用线程安全与否来一言蔽之

应该问，智能指针有哪些线程不安全的隐患：

1. 引用计数的加减操作是否线程安全

2. shared_ptr修改指向时，是否线程安全

3. shared_ptr指向的不是一个类而是一个类模板

《effective modern C++》关于shared_ptr的部分提到，引用计数的递增是原子的（使用了atomic变量，该变量保证了给定操作的原子性，是通过**缓存加锁和总线加锁的方式**来实现的。引用计数变化的操作本身是原子的，但是shared_ptr还涉及资源所有权的操作，这部分并非原子的。

#### 红黑树是如何保证均摊O(logn)的时间复杂度的

#### 场景题：给你一个100亿个数据的文件，然后求出来出现次数最多的数字，数据范围是整型，我没遇过这种场景，我想着直接哈希计数算了，但是他是要求我不能开大数组来计数排序的。至于后面的分治作法，没想到

[从100亿条记录的文本文件中取出重复数最多的前10条_qq_26498709的博客-CSDN博客](https://blog.csdn.net/qq_26498709/article/details/78432054)

#### 算法题：

我感觉很诡异，让我从3道里头挑2道来做

而且是要求我写伪代码，我写得挺鸡肋，他说我漏写了一些点，但是我能答上来，估计是我写烦了，就没完全写，因为LRU缓存那块我自己写了一个双向链表是自定义的，链表操作比较繁琐，然后又很花时间，还没有测试。

1. 最长回文子串（最优解法是马拉车，但是我只记得O(n^2)的dp作法了）

2. 一个字符串所有子串的种类（当时看错了，但是他指出之后我还是没做出来

3. LRU缓存设计 or LFU缓存设计（挑了LRU缓存设计来做）
