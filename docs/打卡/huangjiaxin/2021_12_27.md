[来源](https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24)
# C++基础知识——基本语言

**1. 为何基类的析构函数必须是虚函数，为什么C++默认的析构函数不是虚函数**
- 将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。

- C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。

**2. 说明一下函数指针**
- 函数指针是指向函数的指针变量。C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样
- 调用函数和做函数的参数，比如回调函数
    ```
    char * fun(char * p)  {…}       // 函数fun
    char * (*pf)(char * p);             // 函数指针pf
    pf = fun;                        // 函数指针pf指向函数fun
    pf(p);                        // 通过函数指针pf调用函数fun
    ```

**3. 说明一下fork函数**
- 通过fork()可以创建一个和当前进程映像一样的进程可以通过
- 对于父进程，fork返回0；对于子进程，fork返回其pid；如果fork失败，返回负值
- 最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。即派生+执行
- 在fork进程时，现代的Unix系统例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。

**4. 说明一下C++中析构函数的作用**
- 与构造函数对应，当对象结束其生命周期如对象所在的函数已调用完毕，系统会自动执行析构函数。
- 析构函数名为~className(),它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。
- 编译器也总是会为我们合成一个析构函数, 这个析构函数什么也不做。因此，如果一个类中有指针，且在使用的过程中动态的申请了内存，就应该使用显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。

**5. 类静态函数和虚函数的区别**
> [C++虚函数表深入探索](https://cloud.tencent.com/developer/article/1599283)
- 静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存寻址开销

**6. 说明重载和覆盖**
- 重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中
    ```
    class A
    {
    public:
        void display(int a, int b ) 
        {
            printf("This is first /n");
        }
        void display(int a) 
        {
            printf("This is second/n"); 
        }
    };
    
    int main()
    {
        A a;
        a.display(5);
        return 0;
    }
    ```
- 覆盖，是指 派生类函数覆盖基类函数，只作用于派生类。作用范围不同(分别位于派生类与基类)，函数名字相同，参数相同，基类函数必须有virtual关键字。


**7. 说明strcpy和strlen**

**8. 说明虚函数和多态**

**9. 写个函数在main函数执行前先运行**

**10. 说明智能指针shared_ptr的实现**

**11. C++里是怎么定义常量的？常量存放在内存的哪个位置**

**12. 说明const关键字**