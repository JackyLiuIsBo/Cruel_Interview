##answerer
>作者：dxgzg
链接：https://www.nowcoder.com/discuss/797600?source_id=discuss_experience_nctrack&channel=-1
来源：牛客网

1.多态实现原理？虚函数指针具体怎么找虚函数表？
A:静态多态通过函数重载和运算符重载来实现，动态多态通过虚函数表和虚指针实现。
（存在虚函数的类里头都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表起始位置的虚指针，
虚表是和类对应的，同一个类的所有对象都是用一个虚表，虚表指针是和对象对应的。虚函数表是一个存储类虚成员函数指针的数据结构。虚函数表由编译器生成和维护）
（动态绑定需要符合三个条件：1.通过指针调用函数 2.指针upcast（子类到基类）向上转型 3.调用的是虚函数）


2.如何创建进程？我说./把可执行变成进程。告知不对。又说fork函数创建通过进程id判断一下。还不对。
有点懵，Linux下使用fork创建一个与父进程一样的副本

3.进程布局？堆栈全局代码那些区
- 文本段：共享，只读。存放字面值常量和要执行的机器代码
- 初始化数据段：包含程序已经初始化的全局变量 .data
- 未初始化数据段：包含程序未初始化的全局变量 .bss
- 栈：用来存放局部变量，传递参数，存放函数的返回地址，esp始终指向栈顶，栈中数据越多，esp越小；栈向第内存地址生长
- 堆：用来存放动态分配的对象，常用的malloc和free就是使用堆的内存；堆向高内存地址生长

4.函数压栈过程，包括函数带参数
入栈：
- 参数入栈：从右到左依次将参数压入栈中
- 将返回地址入栈：将当前代码去调用指令的下一条指令的地址压入栈中
- 存储调用方函数的栈帧，其中ebp为栈帧的底部
  栈弹出：是上述过程的逆过程


5.”hello world"存在那个区？
A: "hello world"是常量字符串，存在于只读存储区。如果说是

6.线程私有区和共享区
貌似没有太多资料

7.是个全局变量但我又想是线程独有的怎么办？陈硕永远滴神。__thred关键字，有一小节整好叫善用__thread关键字
A: __thread关键字修饰的变量对应每个线程都有一份独立实体，且它们之间的值互不干扰

8.tcp三次握手、流量控制、拥塞控制、MSS那一套
TCP三次握手的过程：
- 客户端将TCP报文标志位置为1，随机产生一个序号值为J，保存在TCP报文段首部的序列号字段，指明客户端所要连接的服务器的端口，并将该数据包传送给服务器端，客户端进入
  `SYN_SENT'状态
- 服务器端收到数据报后由SYN为1知道客户端请求建立连接，服务器端将TCP报文段的SYN和ACK字段都置为1，
  ack=J+1,随机产生一个序号值为seq=K，并将该数据报发送给客户端以确认连接请求，服务器端进入`SYN_RCVD`状态
- 客户端收到确认后，检查ack是否为J+1,ACK是否为1，如果正确则将标志位ACK置为1，ack = K + 1，并将该数据报发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，
  如果是的话，服务器端与客户端建立连接，双方进入`ESTABLISHED`状态，此时可以传输数据了

流量控制：
TCP的流量控制通过滑动窗口协议来实现，滑动窗口协议既保证了分组无差错，有序接受收，也实现了流量控制。主要方式是接收方返回的ACK会包含自己接收窗口的大小，并且利用大小来控制
发送方的数据发送。为了避免流量控制引起死锁，TCP使用了持续计数器，每当发送方收到零窗口的应答时就启动一次计数器

拥塞控制：
与流量控制不同，拥塞控制是面向网络的，流量控制是面向接收方的。
拥塞控制有四个算法：慢启动，拥塞避免，快重传，快恢复。
慢启动：首先设置拥塞窗口初始值（一般为1）慢启动阶段的慢实际上是指拥塞窗口的大小，本身拥塞窗口的变化是指数增长的，每次收到`ACK`即
每经过一个RTT拥塞窗口都会增大一倍。
直到达到ssthresh.
拥塞避免：设置慢启动的阈值，一旦cwnd达到ssthresh，就进入拥塞避免阶段，该阶段内每个RRT CWND只会+1
将报文段的超时看做是拥塞，一旦发生超时重传，就将ssthresh设置为当前窗口1/2，拥塞窗口设置为1，然后重新
进入慢启动阶段
快速重传：在遇到3次ACK时，代表收到了3个报文段，但之前的1个报文段丢失了，需要对其进行重传
快速恢复：当检测到丢包时，TCP会触发快速重传并进入窗口减小的阶段，快速恢复算法是指导cwnd降到合理值的算法。

MSS：传输层的最大报文段长度。MTU：数据链路层可传输的数据包大小。

9.timewait
time_wait是TCP释放连接后主动关闭连接方发送完最后一次挥手，即ACK=1的状态.time_wait的持续时间是2MSL，即4min，为了保证k客户端发送的最后一个ack报文可以到达服务器端。
但是time_wait有一个问题，持续时间长，如果网络中存在大量time_wait，服务器的压力会很大。

10.客户端握手发送SYN，TCP状态机，client变成什么状态？
第一次握手后，client变成`SYN_SENT`状态，等待服务器端回复

11.相交链表
使用双指针解决链表问题，物理上的追及相遇问题
```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode * a, ListNode * b) {
        ListNode * A = a, * B = b;
        while(A != B){
            A = A? A->next: b;
            B = B? B->next: a;
        }
        return A;
    }
};
```
相似题目：环形链表2
```c++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode * fast = head, * slow = head;
        while(fast != nullptr) {
            fast = fast->next;
            if(!fast || !fast->next) return nullptr;
            fast = fast->next;
            slow = slow->next;
            if(fast == slow) break;
        }
        fast = head;
        while(fast != slow){
            fast = fast->next;
            slow = slow->next;
        }
        return fast;
    }
};
```