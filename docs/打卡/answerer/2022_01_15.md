## C++八股文

### 形参与实参的区别
1. 形参只有在函数被调用时才会分配内存，在调用结束时，即刻释放所分配的内存。形参的作用域是函数体。
2. 形参与实参在数量和类型上应当保持一致
3. 函数调用中数据传送是单向的

### static的作用
1. 隐藏（可作用于函数或者变量），当同时编译多个文件时，所有未加static属性的变量具有当前作用域的全局可见性
2. static的第二个作用是改变变量的生命周期，static变量存放在静态存储区，与全局变量相比，static变量具有隐藏的特性
3. static的变量默认初始化
4. 在类内的static修饰符有以下限制：
- static成员的内存只会分配一次
- static成员只能被成员函数所访问，不能被类外函数访问
- static数据成员必须类外初始化

### 动态联编和静态联编
1. 在c++中，联编是指一个计算机程序不同部分互相关联的过程，按照联编的阶段，可以划分为「静态联编」和「动态联编」
2. 静态联编是在编译阶段完成的，在程序运行之前完成。要实现静态联编，在编译阶段必须确定程序中的操作调用与该操作代码间的关系
3. 动态联编是指联编在程序运行时动态进行，根据当时情况来确定调用那个同名函数，实际上是在运行时虚函数的实现
4.实现动态联编的3个条件：
   1. 必须将动态联编的行为定义为类的虚函数
   2. 类之间应满足子类型行为，即继承类
   3.  基类指针指向子类型的对象，然后直接或间接使用基类指针调用虚函数
    
### 动态编译和静态编译
1. 静态编译，编译器在编译可执行文件时，把需要用到的对应动态链接库中的部分提取出来，连接到可执行文件中去，使可执行文件在运行时不需要依赖于动态链接库；
2. 动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库的命令。所以其优点一方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。缺点是哪怕是很简单的程序，只用到了链接库的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。


### 动态链接和静态链接
1. 静态连接库就是把(lib)文件中用到的函数代码直接链接进目标程序，程序运行的时候不再需要其它的库文件；动态链接就是把调用的函数所在文件模块（DLL）和调用函数在文件中的位置等信息链接进目标程序，程序运行的时候再从DLL中寻找相应函数代码，因此需要相应DLL文件的支持。
2. 静态链接库与动态链接库都是共享代码的方式，如果采用静态链接库，则无论你愿不愿意，lib 中的指令都全部被直接包含在最终生成的 EXE 文件中了。但是若使用 DLL，该 DLL 不必被包含在最终 EXE 文件中，EXE 文件执行时可以“动态”地引用和卸载这个与 EXE 独立的 DLL 文件。静态链接库和动态链接库的另外一个区别在于静态链接库中不能再包含其他的动态链接库或者静态库，而在动态链接库中还可以再包含其他的动态或静态链接库。
3. 动态库就是在需要调用其中的函数时，根据函数映射表找到该函数然后调入堆栈执行。如果在当前工程中有多处对dll文件中同一个函数的调用，那么执行时，这个函数只会留下一份拷贝。但是如果有多处对lib文件中同一个函数的调用，那么执行时，该函数将在当前程序的执行空间里留下多份拷贝，而且是一处调用就产生一份拷贝。

### printf实现原理
在C/C++中，对函数参数的扫描是从后向前的。C/C++的函数参数是通过压入堆栈的方式来给函数传参数的（堆栈是一种先进后出的数据结构），
最先压入的参数最后出来，在计算机的内存中，数据有2块，一块是堆，一块是栈（函数参数及局部变量在这里），
而栈是从内存的高地址向低地址生长的，控制生长的就是堆栈指针了，最先压入的参数是在最上面，就是说在所有参数的最后面，最后压入的参数在最下面，
结构上看起来是第一个，所以最后压入的参数总是能够被函数找到，因为它就在堆栈指针的上方。printf的第一个被找到的参数就是那个字符指针，就是被
双引号括起来的那一部分，函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移量了