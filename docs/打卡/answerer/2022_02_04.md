### C++基础面试题
> 详细的计划打算明天给出，先来复习一遍基础的面经

**1. int main(int argc, char ** argv)，在main函数中的参数有什么含义？**
- 首先，这是可选的，意味着我们可以加上，也可以不加上，这是为了在命令行进行操作而添加的
- 第一个参数argc表示命令行参数的个数
- 第二个参数argv表示命令行参数的字符串数组，它又分为：
    1. argv[0]表示程序运行的绝对路径名
    2. argv[1]表示dos命令行中运行的程序后的第一个字符串
    3. argv[2]表示执行程序名后的第二个字符串
    4. argv[3~n]同理
    5. argv[argc] = NULL
    
**2. struct与union的区别？**

- 两者都可以由多个不同类型的数据成员组成，struct成员都是占用空间的，但是union只有一个被选中的成员占用空间
- 在不考虑内存对齐的情况下，struct的大小等于所有成员大小之和；union的大小等于最大的成员的大小
- struct不同成员之间赋值不会互相影响，但是union不同成员之间赋值会导致原来的成员的值被重写

**3. 原码，反码，补码的区别？**

- 原码：顾名思义，原码，原数的二进制码
- 反码：正数原码等于反码，负数为取反的原码
- 补码：正数的补码等于原码，负数的原码等于反码+1.利用补码的性质可以省略掉一个减法电路，全由加法实现

**4. 堆栈区别？**
首先看这张图：
![img.png](https://github.com/coderhare/Cruel_Interview/blob/main/docs/%E6%89%93%E5%8D%A1/answerer/images/%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E6%A8%A1%E5%9E%8B.png)
- 生长方向：堆从低地址往高地址生长
- 堆栈分配空间方式：栈内存由操作系统分配和释放，存放函数的参数，局部变量等；堆由程序员手动申请和释放
- 效率：栈使用的是一级缓存，堆使用的是二级缓存，效率来说栈高很多
- 空间大小：栈的空间只有2M，堆的空间相比非常大，理论上接近3G
- 能否产生碎片：栈的分配方式是LIFO，不会出现空内存碎片返回的情况，但是堆是由空闲链表组织的，会产生碎片

**5. 简单说说内存泄漏？**
可能发生的场景：
- new或malloc之后，没有及时delete和free释放
- 子类继承父类时，父类析构函数不是虚函数
- 比如文件句柄，socket，自定义资源类没有使用对应的资源释放函数
- shared_ptr共享指针成环，导致循环引用计数，资源得不到释放

如何避免内存泄漏？
1. 良好的编码习惯，分配内存之后一定要使用相应的函数回收空间
2. 使用智能指针
3. 在产品检测中使用内存检测工具如valgrind， leaky等进行检测

**6. 栈和堆内存申请需要注意什么？**
1. 在函数里头不要返回指向栈内存的指针，因为函数结束时，该部分栈内存会被回收
2. 不要返回指向常量区的内存空间，因为常量区生命周期是函数结束时，它的内存是只读的
3. 通过传入一级指针不能解决，因为函数内部指针将指向新的内存地址，可以通过二级指针来解决

**7. 请说说内部碎片和外部碎片？**
- 内部碎片是由于采用了固定大小的内存分区，当一个进程不能完全使用他所占用的内存空间时，就会产生内部碎片
- 外部碎片是由于未分配的某些连续内存块太小，无法给予进程使用而造成的；外部碎片的一个例子就是堆的频繁分配产生的外部碎片

解决方法：
- 段页式管理
- 内存池

**8. malloc内存管理原理**
- 当开辟空间＜128K时，使用brk()函数
- 当开辟空间＞128K时，使用mmap()

malloc采用的是内存池管理技术，使用隐式链表组织所有空闲块，以减少内存碎片






    
