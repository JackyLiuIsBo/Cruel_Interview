## 一、写在前面

今天主要是**GoLang的切片**。



## 二、GoLang

### 0、关于切片

> 参考资料：https://www.cnblogs.com/bonelee/p/6862377.html

一个切片在未初始化之前默认为 nil，长度为 0。

以下三种是等价的：

```go
var slice1 []type = arr1[:] 
arr1[0:len(arr1)]
slice1 := &arr1 // 其实这个和那两种还不太一样。输出%T发现，这个依旧是数组的指针，而不是切片
```

如果想通过一个数组来生成一个切片：

```go
s := [3]int{1,2,3}[:]
s := []int{1,2,3}
s == s[:i] + s[i:] // 这个恒为true
```



### 1、切片在内存中的组织方式

>  切片是对数组一个连续片段的引用（该数组我们称之为相关数组，通常是匿名的），所以切片是一个引用类型（因此更类似于 C/C++ 中的数组类型，或者 Python 中的 list 类型）。切片是一个 长度可变的数组。
>
> 多个切片如果表示同一个数组的片段，它们可以**共享数据**；因此一个切片和相关数组的其他切片是共享存储的，相反，不同的数组总是代表不同的存储。数组实际上是切片的构建块。
>
> 注意 绝对不要用指针指向 slice。切片本身已经是一个引用类型，所以它本身就是一个指针!!

切片在内存中的组织方式实际上是一个有 3 个域的结构体：指向相关数组的指针，切片 长度以及切片容量。下图给出了一个长度为 2，容量为 4 的切片y。



<img src="D:\mystudy\internship\Cruel_Interview\docs\打卡\zhaoxinzhi\assets\2022_02_04\image-20220204164804443.png" alt="image-20220204164804443" style="zoom:50%;" />

### 2、切片的优点

因为切片是引用，所以它们不需要使用额外的内存并且比使用数组更有效率。所以在 Go 代码中 切片比数组更常用。

### 2、new() 和 make() 的区别

看起来二者没有什么区别，**都在堆上分配内存**，但是它们的行为不同，适用于不同的类型。

- new(T) 为每个新的类型T分配一片内存，初始化为 0 并且返回类型为*T的内存地址：这种方法 返回一个指向类型为 T，值为 0 的地址的指针，它适用于值类型如数组和结构体（参见第 10 章）；它相当于 `&T{}`。
- make(T) 返回一个类型为 T 的初始值，它只适用于3种内建的引用类型：切片、map 和 channel（参见第 8 章，第 13 章）。

换言之，new 函数分配内存，make 函数初始化；下图给出了区别：

<img src="D:\mystudy\internship\Cruel_Interview\docs\打卡\zhaoxinzhi\assets\2022_02_04\image-20220204165404519.png" alt="image-20220204165404519" style="zoom:50%;" />

### 3、切片和垃圾回收

通过图7.2也可以发现，实际上可能有很多切片指向同一个底层数组，即切片的底层指向一个数组，该数组的实际容量可能要大于切片所定义的容量。**只有在没有任何切片指向的时候，底层的数组内层才会被释放**，这种特性有时会导致程序占用多余的内存。（像python等其他语言，可能是跟作用域有关系，局部变量退出函数了后，就释放了，但是go不是这样的，因为切片是共享存储）

例子：函数 `FindDigits` 将一个文件加载到内存，然后搜索其中所有的数字并返回一个切片。

```go
var digitRegexp = regexp.MustCompile("[0-9]+")

func FindDigits(filename string) []byte {
    b, _ := ioutil.ReadFile(filename)
    return digitRegexp.Find(b)
}
```



这段代码可以顺利运行，但返回的 `[]byte` 指向的底层是整个文件的数据。只要该返回的切片不被释放，垃圾回收器就不能释放整个文件所占用的内存。换句话说，一点点有用的数据却占用了整个文件的内存。

想要避免这个问题，可以通过拷贝我们需要的部分到一个新的切片中：

```go
func FindDigits(filename string) []byte {
   b, _ := ioutil.ReadFile(filename)
   b = digitRegexp.Find(b)
   c := make([]byte, len(b))
   copy(c, b)
   return c
}
```

