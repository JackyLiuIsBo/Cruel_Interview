## 一、写在前面

今天把网页中存的最后一点关于**计算机网络**的看完，然后继续**操作系统**。

## 二、计算机网络

> 链接https://www.cnblogs.com/wanpengcoder/p/5366156.html

### 1、Nagle算法

目的：为了减少广域网的小分组数目，从而减小网络拥塞的出现。

该算法要求**一个TCP连接上最多只能有一个未被确认的未完成的小分组，在该分组ack到达之前不能发送其他的小分组，TCP需要收集这些少量的分组，并在ack到来时以一个分组的方式发送出去**。其中小分组的定义是小于MSS的任何分组；

算法的优势：算法优越之处在于它是自适应的，确认到达的越快，数据也就发送的越快；而在希望减少微小分组数目的低速广域网上，则会发送更少的分组。

> Nagle算法发送数据与确认示意图：
>
> ![image-20220112214601827](D:\mystudy\internship\Cruel_Interview\docs\打卡\zhaoxinzhi\assets\2022_01_12\image-20220112214601827.png)



### 2、MSS和MTU

**MTU： Maximum Transmit Unit，最大传输单元**，即物理接口（数据链路层）提供给其上层（通常是IP层）最大一次传输数据的大小；以普遍使用的以太网接口为例，缺省MTU=1500 Byte，这是以太网接口对IP层的约束，如果IP层有<=1500 byte 需要发送，只需要一个IP包就可以完成发送任务；如果IP层有> 1500 byte 数据需要发送，需要分片才能完成发送，这些分片有一个共同点，即IP Header ID相同。

**MSS：Maximum Segment Size ，最大报文段长度。**TCP提交给IP层最大分段大小，不包含TCP Header和 TCP Option，只包含TCP Payload ，MSS是TCP用来限制application层最大的发送字节数。如果底层物理接口MTU= 1500 byte，则 MSS = 1500- 20(IP Header) -20 (TCP Header) = 1460 byte，如果application 有2000 byte发送，需要两个segment才可以完成发送，第一个TCP segment = 1460，第二个TCP segment = 540。

### 3、延迟ACK

如果tcp对每个数据包都发送一个ack确认，那么只是一个单独的数据包为了发送一个ack代价比较高，所以tcp会延迟一段时间，如果这段时间内有数据发送到对端，则捎带发送ack，如果在延迟ack定时器触发时候，发现ack尚未发送，则立即单独发送；

延迟ACK好处：

(1) 避免糊涂窗口综合症；

(2) 发送数据的时候将ack捎带发送，不必单独发送ack；

(3) 如果延迟时间内有多个数据段到达，那么允许协议栈发送一个ack确认多个报文段；



### 4、糊涂窗口综合症

> 链接https://blog.csdn.net/weixin_43705457/article/details/103413045

糊涂窗口综合征(Silly Window syndrome SWS)是一个发送端与接收端处理包不一致，导致出现接收端的通告窗口过小 再导致发送端窗口过小 从而导致产生大量的小数据包，这样的小数据包中头部占比大，导致传输效率低下，这样的行为就叫做糊涂窗口综合征。

### 5、Nagle和延迟ACK同时启用，带来的问题

试想如下典型操作，写-写-读，即本地调用两次`write`， 对端再调用一次`read`。”写-写-读“是通过多个写小片数据向对端发送单个逻辑的操作，两次写数据长度小于MSS。根据Nagle算法，先发送第一个小片数据并等待ack到来再发送后续数据包。第一次写数据到达对端后，对端延迟ack，不发送ack，而本端因为要发送的数据长度小于MSS，所以nagle算法起作用，数据并不会立即发送，而是等待对端发送的第一次数据确认ack；这样的情况下，需要等待对端超时发送ack，然后本端才能发送第二次写的数据，从而造成延迟；

### 6、哪些场景适用于关闭Nagle算法

使用TCP套接字选项TCP_NODELAY可以关闭套接字选项。

如下场景考虑关闭Nagle算法：

-  对端不向本端发送数据，并且对延时比较敏感的操作；这种操作没法捎带ack；



> 对于”写写读“操作，有以下三种处理方式：（优先使用前两种方式，而不是关闭Nagle算法）
>
> 1. 使用`writev`，而不是两次调用`write`，单个`writev`调用会使TCP输出一次而不是两次，即只产生一个TCP分节，这是首选方法；
> 2. 把两次写操作的数据复制到单个缓冲区，然后对缓冲区调用一次`write`；
> 3. 关闭Nagle算法，调用`write`两次；有损于网络，通常不考虑；





## 三、操作系统

### 1、进程的异常控制流：陷阱、中断、异常和信号

陷阱是**有意**造成的“异常”，是执行一条指令的结果。陷阱是同步的。陷阱的主要作用是实现**系统调用**。比如，进程可以执行 `syscall n` 指令向内核请求服务。当进程执行这条指令后，会中断当前的控制流，**陷入**到内核态，执行相应的系统调用。内核的处理程序在执行结束后，会将结果返回给进程，同时退回到用户态。进程此时继续执行**下一条指令**。

中断由处理器**外部**的**硬件**产生，不是执行某条指令的结果，也无法预测发生时机。由于中断独立于当前执行的程序，因此中断是异步事件。中断包括 I/O 设备发出的 I/O 中断、各种定时器引起的时钟中断、调试程序中设置的断点等引起的调试中断等。

异常是一种错误情况，是执行当前指令的结果，可能被错误处理程序修正，也可能直接终止应用程序。异常是同步的。这里特指因为执行当前指令而产生的**错误情况**，比如除法异常、缺页异常等。有些书上为了区分，也将这类“异常”称为**“故障”**。

信号是一种**更高层的**软件形式的异常，同样会中断进程的控制流，可以由进程进行处理。一个信号代表了一个消息。信号的作用是用来**通知进程**发生了某种系统事件。

### 2、什么是用户态和内核态？

为了限制不同程序的访问能力，防止一些程序访问其它程序的内存数据，CPU划分了用户态和内核态两个权限等级。

- 用户态只能受限地访问内存，且不允许访问外围设备，没有占用CPU的能力，CPU资源可以被其它程序获取；
- 内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换。

所有用户程序都运行在用户态，但有时需要进行一些内核态的操作，比如从硬盘或者键盘读数据，这时就需要进行系统调用，使用**陷阱指令**，CPU切换到内核态，执行相应的服务，再切换为用户态并返回系统调用的结果。

> 进一步：
>
> Q1：为什么要分用户态和内核态？
>
> A1：
>
> - 安全性：防止用户程序恶意或者不小心破坏系统/内存/硬件资源；
> - 封装性：用户程序不需要实现更加底层的代码；
> - 利于调度：如果多个用户程序都在等待键盘输入，这时就需要进行调度；统一交给操作系统调度更加方便。
>
> Q2：如何从用户态切换到内核态？
>
> A2：
>
> - 系统调用：比如读取命令行输入。本质上还是通过中断实现
> - 用户程序发生异常时：比如缺页异常
> - 外围设备的中断：外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理对应的中断处理程序。（外围设备比如键盘鼠标打印机显示器**硬盘**等）

### 3、进程调度策略有哪些？

- 批处理系统：

  - 先来先服务 first-come first-serverd（FCFS）
  - 最短作业优先 shortest job first（SJF）
  - 最短剩余时间优先 shortest remaining time next（SRTN）
  - 最高响应比优先 Highest Response Ratio Next（HRRN）

- 交互式系统

  - > 交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

  - 时间片轮转 Round Robin

  - 优先级调度算法

  - 多级反馈队列调度算法 Multilevel Feedback Queue

### 4、关于优先级反转

高优先级的进程等待被一个低优先级进程占用的资源时，就会出现**优先级较低的进程比优先级较高的进程先执行**。

如下情景：如果有一个中等优先级的进程将低优先级的进程抢占，那么此时低优先级的进程无法正常进行并在后续释放被占用的资源，这时来了一个高优先级的任务，但是由于拿不到资源（被低优先级的任务占用），导致高优先级的任务一直被挂起，直到中等优先级的进程完成后，低优先级的进程才可以继续并在后续释放占用的资源，最后高优先级的进程才可以执行。导致的问题就是高优先级的进程在中等优先级的进程调度之后。

解决方法：

- 优先级天花板(priority ceiling)：当任务申请某资源时，把该任务的优先级提升到可访问这个资源的所有任务中的最高优先级，这个优先级称为该资源的优先级天花板。简单易行。（没看懂....）
- 优先级继承(priority inheritance)：当任务A申请共享资源S时，如果S正在被任务C使用，通过比较任务C与自身的优先级，如发现任务C的优先级小于自身的优先级，则将任务C的优先级提升到自身的优先级，任务C释放资源S后，再恢复任务C的原优先级。
