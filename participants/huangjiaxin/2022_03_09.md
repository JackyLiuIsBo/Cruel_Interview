# 计算机网络(二)
**HTTP 1.0、HTTP 1.1及HTTP 2.0的主要区别是什么**
> HTTP/1.x 是基于文本的，只能整体去传；HTTP/2 是基于二进制流的，可以分解为独立的帧，交错发送
HTTP/1.x keep-alive 必须按照请求发送的顺序返回响应；HTTP/2 多路复用不按序响应
HTTP/1.x keep-alive 为了解决队头阻塞，将同一个页面的资源分散到不同域名下，开启了多个 TCP 连接；HTTP/2 同域名下所有通信都在单个连接上完成
HTTP/1.x keep-alive 单个 TCP 连接在同一时刻只能处理一个请求（两个请求的生命周期不能重叠）；HTTP/2 单个 TCP 同一时刻可以发送多个请求和响应

1. HTTP/1.0 —— 无状态无连接的应用层协议
- 无状态：服务器不跟踪不记录请求过的状态
- 无连接：浏览器每次请求都需要建立tcp连接
HTTP/1.0规定浏览器和服务器保持短暂的连接。浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。无状态导致的问题可以借助cookie/session机制来做身份认证和状态记录解决。
然而，无连接特性将会导致以下性能缺陷：
- 无法复用连接。每次发送请求的时候，都需要进行一次TCP连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会导致网络的利用率非常低。
- 队头堵塞(head of line blocking)。由于HTTP/1.0规定下一个请求必须在前一个请求响应到达之前才能发送。假设一个请求响应一直不到达，那么下一个请求就不发送，就到导致阻塞后面的请求。

2. HTTP/1.1
- 长连接。HTTP/1.1增加了一个Connection字段，通过设置Keep-alive（默认已设置）可以保持连接不断开，避免了每次客户端与服务器请求都要重复建立释放TCP连接，提高了网络的利用率。如果客户端想关闭HTTP连接，可以在请求头中携带Connection:false来告知服务器关闭请求
- 支持请求管道化（pipelining）。基于HTTP/1.1的长连接，使得请求管线化成为可能。管线化使得请求能够“并行”传输。举个例子来说，假如响应的主体是一个html页面，页面中包含了很多img，这个时候keep-alive就起了很大的作用，能够进行“并行”发送多个请求。（注意这里的“并行”并不是真正意义上的并行传输，具体解释如下。）

**Session、Cookie和Token的主要区别**

**在浏览器中输⼊url地址到显示主⻚的过程**
> []()
- 简单版
    - 1、浏览器根据请求url 交给 DNS 域名解析，解析完成之后得到 Ip 地址，这个时候访问服务器。
    - 2、服务器交给后台处理完成返回数据，浏览器通过 nginx 接收 Html、css、js
    - 3、浏览器对加载的资源  Html、css、js进行解析建立相应数据结构。
    - 4、载入解析到的资源文件，渲染页面，完成加载。
- 详细版
    - 浏览器输入URL 之后
    - 浏览器会先查看缓存，有缓存了则加载缓存，如果没有则加载新资源如下：
        - 1、没缓存请求新数据，有缓存检验是否足够新，够新则直接客户端，不新则请求服务端。
        - 2、检验新鲜通常有两个Http头进行控制，Expires 和 Cache-Control: 区别在于，一个值为一个绝对时间表示缓存的新鲜与否，另一个则是以秒为单位计算出最大的新鲜值时间。
    - 浏览器解析URL获取协议，主机，端⼝，path
    - 浏览器组装⼀个HTTP（GET）请求报⽂
    - 浏览器获取主机ip地址，过程如下：
        - 浏览器缓存
        - 本机缓存
        - hosts⽂件
        - 路由器缓存
        - ISP DNS缓存
        - DNS递归查询（可能存在负载均衡导致每次IP不⼀样）
    - 打开⼀个socket与⽬标IP地址，端⼝建⽴TCP链接，三次握⼿如下：
        - 客户端发送⼀个TCP的SYN=1，Seq=X的包到服务器端⼝
        - 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包
        - 客户端发送ACK=Y+1， Seq=Z
    - TCP链接建⽴后发送HTTP请求
    - 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使⽤HTTP Host头部判断请 求的服务程序
    - 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码
    - 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作
    - 服务器将响应报⽂通过TCP连接发送回浏览器
    - 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重⽤，关闭TCP连接的四 次握⼿如下：
        - 主动⽅发送Fin=1， Ack=Z， Seq= X报⽂
        - 被动⽅发送ACK=X+1， Seq=Z报⽂
        - 被动⽅发送Fin=1， ACK=X， Seq=Y报⽂
        - 主动⽅发送ACK=Y， Seq=X报⽂
    - 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同
    - 如果资源可缓存，进⾏缓存
    - 对响应进⾏解码（例如gzip压缩）
    - 根据资源类型决定如何处理（假设资源为HTML⽂档）
    - 浏览器渲染页面。不细说。

**什么是跨域问题?如何解决**