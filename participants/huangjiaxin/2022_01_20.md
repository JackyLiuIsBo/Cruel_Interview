# redis总结(二)
**4.redis 服务端网络请求处理模型**
reactor模型。
- 从 Redis 的 v1.0 到 v6.0 版本之前， 是一个单reactor模型，利用 epoll/select/kqueue 等多路复用技术，在单线程的事件循环中不断去处理事件（客户端请求），最后回写响应数据到客户端。
    ![](images/redis-reactor.png)
- v6.0之后，引入多线程之后会进化为 Multi-Reactors 模式
![](images/multi-reactors.png)
    - 大部分逻辑和之前的单线程模型是一致的，变动的地方仅仅是把读取客户端请求命令和回写响应数据的逻辑异步化了，交给 I/O 线程去完成，这里需要特别注意的一点是：I/O 线程仅仅是读取和解析客户端命令而不会真正去执行命令，客户端命令的执行最终还是要在主线程上完成。


**5.redis单线程模型为何效率高**
- 避免过多的上下文切换开销
- 避免同步机制的开销
- 纯内存操作，CPU通常不会是瓶颈，瓶颈通常是网络IO
- 简单可维护
**6.redis单线程如何提高多核CPU利用率**
- 在同一个服务器上部署多个redis实例
    - 使用taskset命令将每个实例和CPU内核进行绑定。例如`taskset -pc 3 <redis的pid>`

**7.redis持久化方式**
- RDB持久化
    - RDB文件用于保存和还原Redis服务器所有数据库中的所有键值对数据。RDB文件是一个经过压缩的二进制文件，由多个部分组成。
    - SAVE命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器。BGSAVE令由子进程执行保存操作，所以该命令不会阻塞服务器。
    - 服务器状态中会保存所有用save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行BGSAVE命令。
- AOF持久化
    - AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的
    - AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。通过读取现有数据库的键值对实现


**8.redis数据过期策略与内存淘汰策略**
- 数据过期策略
    - 定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。内存友好，CPU占用高
    - 惰性过期：只有访问一个key时才判断是否已经过期，过期则清除。内存不友好，节省CPU
    - 定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。
    - Redis中同时使用了惰性过期和定期过期两种过期策略。
- 内存淘汰策略
    - 指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。
    - noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。
    - allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。
    - allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。
    - volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
    - volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
    - volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。
