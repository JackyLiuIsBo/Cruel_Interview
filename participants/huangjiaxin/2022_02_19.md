# Go基础(五)

**11. Golang中常用的并发模型**

有三种。
- 通过channel通知实现并发控制。
    ```
    func main() {
        ch := make(chan struct{})
        go func() {
            fmt.Println("start working")
            time.Sleep(time.Second * 1)
            ch <- struct{}{}
        }()

        <-ch

        fmt.Println("finished")
    }
    ```
- 通过sync包中的WaitGroup实现并发控制。它会等待它收集的所有 goroutine 任务全部完成。同一个WaitGroup如何在多个goroutine中共用？
    - WaitGroup类型作为参数传递时应作为指针类型传递。
    - 将匿名函数中的 wg 的传入参数去掉，因为Go支持闭包类型，在匿名函数中可以直接使用外面的 wg 变量.
    ```
    func main(){
        var wg sync.WaitGroup
        var urls = []string{
            "http://www.golang.org/",
            "http://www.google.com/",
        }
        for _, url := range urls {
            wg.Add(1)
            go func(url string) {
                defer wg.Done()
                http.Get(url)
            }(url)
        }
        wg.Wait()
    }
    ```
- 在Go 1.7 以后引进的强大的Context上下文，实现并发控制.
