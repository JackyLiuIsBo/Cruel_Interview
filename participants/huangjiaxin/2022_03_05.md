# 操作系统(三)
**生产者消费者模型**
待补充
**死锁发生条件，如何避免死锁，如何处理死锁**
- 什么是死锁？
    - 两个或多个进程无限期的阻塞、相互等待的一种状态。
- 死锁产生的四个必要条件
    - 互斥条件：一个资源一次只能被一个进程使用
    - 请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放
    - 不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺
    - 循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系
- 如何处理死锁
    - 忽略该问题
    - 检测死锁并且恢复。
    - 仔细地对资源进行动态分配，以避免死锁。
    - 通过破除死锁四个必要条件之一，来防止死锁产生。


**讲讲虚拟内存？**
- 为什么要有虚拟内存？
    - 硬件工程师对物理内存的设计需求
        - 内存需要被分割成足够小的块，且没有段的概念；这个块被称为内存的“页”，这个分割过程也就是“分页”的过程，Linux 将每页定义为 4K 大小；为什么需要把一个程序分割成这么小的页呢？目的就是为了避免过大的内存碎片，提高内存的使用率；
        - 内存不是被某个进程独占的，分配给进程(程序)的块也是不连续的，
        每个内存块可以分配给任意一个进程，因此分配给进程的内存块必然不是连续的，块与块之间是有间隙的；
    - 软件工程师对内存的设计需求
        - 需要内存被程序独占；
        - 需要将程序使用分段保存，且段内的内存地址必须是连续的；
        - 通常一段程序包含的段有，代码段、数据段、堆段、栈段等
    - 通过虚拟内存去解耦硬件工程师的诉求和软件工程师的诉求
- 虚拟内存是什么？
    - 虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。程序执行时使用的是逻辑地址，逻辑地址通过地址映射得到物理地址。这使得只有4G物理内存的机器可以运行多个内存占用总和超过4G的程序。
    - 直接把物理地址暴露给用户程序，使得同一时间只能有一个程序加载到内存中。且如果用户程序可以寻址内存中的每个字节，那么操作系统很容易破坏掉。
    - 每个进程都有自己的地址空间。这些地址空间被划分为多个称为页面的块。当
- 虚拟内存的实现机制
    - 通过MMU实现虚拟地址到物理地址的映射。指令中的地址都是虚拟地址，在执行指令时如果要读写内存会通过MMU获取到物理地址后进行内存的读写。如果页表中有此虚拟地址到
    ![](images/virtual_to_physical_memory.jpg)
    - MMU如何将16位(64k)虚拟地址映射为15位(32位)物理地址。说明虚拟内存和物理内存的映射机制，真实操作系统不是如此。
    ![](images/MMU.jpg)
    ![](images/MMU%E8%AF%B4%E6%98%8E.jpg)
    - 32位操作系统的虚拟内存实现机制参见[虚拟地址->物理地址](https://www.shangyang.me/2019/11/19/os-basic-30-memory-management/#%E9%A1%B5%E6%A1%86)
        - 此篇文章回答了分页、分段，逻辑地址->线性地址->物理地址的过程

**页面置换算法**



**IO模型**
IO（Input/Output，输入/输出）即数据的读取（接收）或写入（发送）操作。
通常用户进程中的一个完整IO分为两阶段：用户进程空间与内核空间之间的相互切换、内核空间与设备空间的相互切换（磁盘、网络等）。我们通常说的IO是指网络IO和磁盘IO两种。
Linux中进程无法直接操作I/O设备，其必须通过系统调用请求内核来协助完成I/O动作；内核会为每个I/O设备维护一个缓冲区。
对于一个输入操作来说，进程IO系统调用后，内核会先看缓冲区中有没有相应的缓存数据，没有的话再到设备中读取，因为设备IO一般速度较慢，需要等待；内核缓冲区有数据则直接复制到进程空间。
所以，对于一个网络输入操作通常包括两个不同阶段：

等待网络数据到达网卡→读取到内核缓冲区，数据准备好；
从内核缓冲区复制数据到进程空间。
5种IO模型如下：

- 阻塞IO：进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程。操作成功则进程获取到数据。调用者将一直等待，不停的检查这个函数有没有返回，必须等这个函数返回后才能进行下一步动作。
- 非阻塞IO：进程发起IO系统调用后，进程被阻塞，内核数据还没好，不想让进程等待，就返回一个错误，这样进程就不阻塞了。进程每隔一段时间就发起IO系统调用去检查IO事件是否就绪。这样就实现非阻塞了。每个进程都有一个时间片，轮询的时候读取IO，时间片到了就要换另一个进程做其他事情了，这样就做到了每隔一段时间发起IO系统调用。
- IO多路复用：Linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检查。select/poll会监听所有的IO，直到有数据可读或可写时，才真正调用IO操作函数。
- 信号驱动IO：Linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到SIGIO信号，然后处理IO事件。这个好理解，这个信号直接通知进程数据到了。
- 异步IO：进程发起IO系统调用后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。用户可以直接去使用数据。具体操作是进程调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回。

前四种属于同步IO，原因就在于进程发起IO系统调用读取数据时，这个真正拿到数据的过程依然是阻塞的，直到完成数据读取还要把数据拷贝到用户空间中，进程才能继续做其他事。
而异步IO就不一样了，进程完全做自己的事情，数据都不需要它读取，而是由内核读取数据并将数据拷贝到缓冲区后，再通知应用程序。用户可以直接去使用数据。

**select, poll, epoll**
待补充