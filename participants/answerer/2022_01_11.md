
### C++从文本到可执行文件需要经过的四个阶段
1. 预处理阶段：对头文件和宏定义进行替换和分析，生成预编译文件
2. 编译阶段：将预编译文件转换为特定的汇编文件
3. 将编译阶段生成的汇编文件代码转换为机器码，生成可重定位目标文件
4. 将多个目标文件及其所需要的库连接成最终的可执行目标文件

### new和malloc的区别
1. new分配内存按照数据类型进行分配，malloc分配内存按照指定的大小分配
2. new不仅会分配一段内存，还会调用构造函数，malloc不会
3. new返回的是对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化；同样的，
   delete会调用类的析构函数，而free不会
4. new是一个操作符可以重载，malloc是一个库函数
5. new如果分配失败会抛出bad_alloc异常，malloc失败会返回空指针

### 静态函数可以是虚函数吗？
- A: 不能。因为static成员不属于任何类对象或者类实例，加上virtual关键字也是没有用的。
静态成员函数和非静态成员函数还有一个区别，静态成员函数不能访问this指针，不能访问vptr，进而不能访问虚函数表
  
### C++ STL的内存实现

容器vector, deque, list, map, set等。

Vector扩容就是重新申请一段更长的连续内存空间并把以前的数据移动过去，释放以前的内存空间。以前的迭代器都会失效。一般用VS扩容都是扩容现有容器容量的2倍，有的是1.5倍。

vector

优点：

1. 动态数组，当空间大小不够时，可以自动扩增，每次扩增大小为原来的3倍或者1.5倍。

2. 查询效率很高。

缺点：

1. 扩增空间的时候需要重新指向一个连续的内存空间，效率低。

2. 插入删除需要移动元素，效率低。

注意：删除容器中数据的时候，缓冲区大小并不会改变，仅仅只是清除了其中的数据，只有在析构函数调用的时候vector才会自动释放缓冲区。

可以强制释放vector的缓冲区。

reserve和resize的区别是什么？

reserve只是开辟空间并不创建元素。而resize重新开辟空间并自动初始化元素。

reserve和resize的区别：[两者区别](vector.resize 与 vector.reserve的区别)

vector内部实现？

Vector是一个类，它里面有三个指针myfirst,mylast,myend.分别表示首地址，元素容量地址，容器容量地址。通过这三个指针分别表示容器的所有操作。

什么是迭代器失效？

就是比如vector容器扩容的时候，释放了原来的内存空间，导致原来的迭代器都失效不能用了。

迭代器失效就是因为扩容，删除元素等缘故，导致原先容器的空间变化，进而导致迭代器（begin()和end()）发生了变化，从而失效。

vector.push_back()一个值，内部发生什么？

如果容量充足，就会在容器末尾添加该元素，如果容量不足，就会自动扩容，扩容的时候会重新寻找一个更大的连续内存，原来的迭代器会失效。扩容一般会扩大现有容器量的2倍。



deque:（由一段一段定量的连续空间构成）

deque 的最大任务就是在这些分段的连续空间上，维护其整体连续的假象，并提供随机存取的接口。deque为了维持整体连续的假象，设计一个中控器，其用来记录deque内部每一段连续空间的地址。大体上可以理解为deque中的每一段连续空间分布在内存的不连续空间上，然后用一个所谓的map作为主控，记录每一段内存空间的入口，从而做到整体连续的假象。

优点：

1. 动态数组，一旦需要扩容，就是在首尾配置一段定量连续空间。

2. 可以双端插入删除。d1.push_back(5); d1.push_front(-5);

3. 查询效率高。



缺点：
1. 不适合中间删除插入。

2. 占用内存多。（暂时不太清楚原因！）



list：（由双向链表（doubly linked list）实现而成）

优点：

1. 任意地方都可以插入删除，插入删除效率高。

缺点：

1. 随机访问效率差。

2. 没有空间预留习惯，所以每分配一个元素都会从内存中分配。



set：（由红黑树实现）

优点：

1. 可以自动排序。

2. 不需要做内存拷贝，插入删除效率高。

3. 方便查找。

缺点：

1. 插入删除时为了在二叉树上找到合适位置，会影响效率。



map:（由红黑树实现）

优点：

1. 插入删除效率高。

2. 扩容不会影响其他元素。

3. key值会自动排序。

缺点：

1. 每次插入值的时候，都需要调整红黑树，效率有一定影响。

