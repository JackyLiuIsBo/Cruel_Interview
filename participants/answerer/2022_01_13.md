# 自己整理的C++八股文

### C的struct和C++的struct有什么区别：
C语言中struct是用户自定义数据类型，C++中struct是抽象数据类型，可以拥有成员函数。说白了，
C++的struct相当于成员函数都是public的类。

### 多态性
C++支持两种多态：
1. 静态多态：通过函数重载实现
2. 动态多态：通过虚函数实现（在运行时才确定调用的是哪个函数，
通过基类指针指向派生类的对象，并调用派生类的函数，也就是说多态的原理是虚函数表和虚函数指针）

### 继承机制中对象之间如何转换？指针与引用之间如何转换？
1. 向上类型转换（将派生类指针或引用转换为基类指针或引用，这是类型安全的转换）
2. 向下类型转换（将基类指针或引用转换为派生类的指针或引用，由于一个基类可能对应多个派生类，因此这种转换
需要附加条件，动态类型识别技术，用dynamic_cast进行向下类型转换
   
### 野指针的定义，成因，和避免方法
野指针：指向被释放内存或没有访问权限的内存的指针。

成因：
1. 指针变量没有初始化为NULL
2. 指针被free或delete后没有设为NULL
3. 数组越界

避免方法：
1. 对指针进行初始化为NULL
2. 指针用完后释放内存，指向NULL

另外，对于内存泄漏问题推荐使用智能指针来减轻心智负担

### delete p; delete []p, allocator
1. 动态数组管理new一个数组时，[]中必须是一个整数，但不一定是常量整数，而常量数组必须是常量整数
2. new动态数组返回的不是数组类型而是一个元素类型的指针
3. delete[]时，数组的元素按逆序进行销毁
new在内存分配上有一些局限性，new的机制是将内存分配和对象构造组合在一起，同样的，delete也是将内存释放和
对象析构组合在一起。allocator将这两部分分开进行，allocator先申请一部分内存，不构造对象，只有在需要的时候才进行
初始化操作。
   

### 78.函数调用过程栈的变化，返回值和参数变量哪个先入栈？

1. 调用者函数把被调函数所需要的参数按照与被调函数的形参顺序相反的顺序压入栈中,即:从右向左依次把被调函数所需要的参数压入栈;
2. 调用者函数使用call指令调用被调函数,并把call指令的下一条指令的地址当成返回地址压入栈中(这个压栈操作隐含在call指令中);
3. 在被调函数中,被调函数会先保存调用者函数的栈底地址(push ebp),然后再保存调用者函数的栈顶地址,即:当前被调函数的栈底地址(mov ebp,esp);
4. 在被调函数中,从ebp的位置处开始存放被调函数中的局部变量和临时变量,并且这些变量的地址按照定义时的顺序依次减小,即:这些变量的地址是按照栈的延伸方向排列的,先定义的变量先入栈,后定义的变量后入栈;
   


