## 一、写在前面

关于操作系统中，虚拟内存啊，进程内存分配啊，之类的问题都放在这个专题下了。

> 参考链接：https://blog.csdn.net/cl_linux/article/details/80328608

## 二、进程空间，内存分配

### 1、进程的地址空间分配

对于一个C语言进程，其空间分布如下图所示：

<img src="D:\mystudy\internship\Cruel_Interview\participants\zhaoxinzhi\assets\2022_02_25Linux进程地址空间分布\image-20220223001220354.png" alt="image-20220223001220354" style="zoom:50%;" />

**程序段(Text):**程序代码在内存中的映射，存放函数体的二进制代码。

**初始化过的数据(Data):**在程序运行初已经对变量进行初始化的数据。

**未初始化过的数据(BSS):**在程序运行初未对变量进行初始化的数据。

**栈 (Stack):**存储局部、临时变量，函数调用时，存储函数的返回指针，用于控制函数的调用和返回。在程序块开始时自动分配内存,结束时自动释放内存，其操作方式类似于数据结构中的栈。

**堆 (Heap):**存储动态内存分配,需要程序员手工分配,手工释放.注意它与数据结构中的堆是两回事，分配方式类似于链表。

其中，Text, BSS, Data段在编译时已经决定了进程将占用多少VM

正常情况下，Linux进程不能对用来存放程序代码（即Text段）的内存区域执行写操作，即程序代码是以只读的方式加载到内存中，但它可以被多个进程安全的共享。

> 背过这个图：https://www.cnblogs.com/lxy-xf/p/11075239.html
>
> <img src="D:\mystudy\internship\Cruel_Interview\participants\zhaoxinzhi\assets\2022_02_25Linux进程地址空间分布\image-20220223002321358.png" alt="image-20220223002321358" style="zoom:50%;" />



### 2、Linux虚拟地址空间

Linux的虚拟地址空间范围为0～4G，Linux内核将这4G字节的空间分为两部分， 将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF）供内核使用，**称为“内核空间”**。而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF）供各个进程使用，**称为“用户空间“**。因为每个进程可以通过系统调用进入内核，因此，Linux内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。

Linux使用两级保护机制：0级供内核使用，3级供用户程序使用，每个进程有各自的私有用户空间（0～3G），这个空间对系统中的其他进程是不可见的，最高的1GB字节虚拟内核空间则为所有进程以及内核所共享。

虽然内核空间占据了每个虚拟空间中的最高1GB字节，但映射到物理内存却总是从最低地址（0x00000000）

程序在被装载入内存前，都是虚拟地址编址？（==而且只能对用户空间编址？==）然后装载入内存之后再有一个地址转换机构进行地址转换。地址转换的过程，是通过页表（page table）映射到物理内存，页表由操作系统维护并被处理器引用。每个进程都拥有一套属于它自己的页表。



### 3、虚拟内存技术

现代的操作系统都处于32位保护模式下。每个进程一般都能寻址4G的物理空间。但是我们的物理内存一般都是几百M，进程怎么能获得4G 的物理空间呢？通常我们使用一种叫做虚拟内存的技术来实现，因为可以**使用硬盘中的一部分来当作内存使用 。**

内核空间在页表中拥有较高的特权级（ring2或以下），因此只要用户态的程序试图访问这些页，就会导致一个页错误（page fault）。在Linux中，内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存，内核代码和数据总是可寻址的，随时准备处理中断和系统调用。与之相反，用户模式地址空间的映射随着进程切换的发生而不断的变化

### 4、堆和栈的区别

![image-20220223002504484](D:\mystudy\internship\Cruel_Interview\participants\zhaoxinzhi\assets\2022_02_25Linux进程地址空间分布\image-20220223002504484.png)