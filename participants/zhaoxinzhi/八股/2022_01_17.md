## 一、写字前面

今天继续**操作系统**。

## 二、操作系统

### 一、什么时候选择多线程？什么时候选择多进程呢？

**CPU密集型情况下，使用多进程。**即重复操作多、且重复操作多为计算操作时，使用多进程。因为能够高效利用多核CPU资源，提升程序的运行速度。（Python因为有全局锁，所以无法多核多线程）

**IO密集型情况下，多进程多线程都可以。**比如爬虫、频繁的io读取、计算等操作。

我们可以认为进程和线程的区别在于完全独立的地址空间。实际考虑的时候还有上下文切换、资源等因素。

每个进程都有都有独立的代码和数据空间（程序上下文），因此它们之间的资源分配和调度也相互独立。

线程也有线程的上下文。

### 二、父子进程和普通进程的区别

父子进程之间有进程目录。

父进程结束后，子进程会变成孤儿进程，由init进程托管（进程号为1的）（这一点仅针对C吗？改天用py试试）

父子进程的堆区数据、栈区数据、全局数据是不共享的。

父子进程可以同时操作同一个文件，在父子进程中，文件描述符以及文件偏移量，都是共享的。

> 为什么操作文件是共享的？
>
> 在linux源码里，每个进程都有一个PCB（进程控制块）结构体，每个PCB里，存了一个结构体指针指向一个我们理解为文件描述符的结构体struct file，而这个结构体里，才存了文件的id，从什么地方开始写，模式等等。值得注意的事，这个结构体里有一个指针才是指向真正的文件的。
>
> **所以其实不是父子进程共享的，而是所有进程都可以共同操作同一文件？**改天测试下。



### 三、关于守护进程和守护线程

#### 什么是守护进程？     

1、守护进程会在主进程代码运行结束的情况下，立即挂掉。     

2、守护进程本身就是一个子进程。

3、主进程在其代码结束后就已经算运行完毕了（守护进程在此时就被回收）,然后主进程会一直等非守护的子进程都运行完毕后回收子进程的资源(否则会产生僵尸进程)，才会结束。

4、守护进程不会守护除了主进程代码之外的其他子进程。

#### 为什么需要守护进程？

#### 何时需要守护进程？

当需要子进程执行的任务生命周期伴随着主进程的生命周期时，就需要将该子进程做成守护进程。

比如一些定期检查的任务



#### 关于守护线程

守护线程会在"该进程内所有非守护线程全部都运行完毕后,守护线程才会挂掉"。并不是主线程运行完毕后守护线程挂掉。

守护线程守护的是：当前进程内所有的非守护线程！（可以算上主线程理解，也可以不算上理解，因为主线程和守护线程是一起死的。）

主线程在其他非守护线程运行完毕后才算运行完毕（守护线程在此时就被回收）这里的运行完毕就是线程死掉了，回收了。因为主线程的结束意味着进程的结束，进程整体的资源都将被回收，而进程必须保证非守护线程都运行完毕后才能结束。守护线程有一个特征，那就是会和主线程一起死掉。

主线程的生命周期就是一个进程的生命周期

主进程等待子进程是因为主进程要负责回收子进程的系统资源

主线程等待子线程是因为主线程要等待子线程运行完毕(子线程运行完毕后,这个进程才算运行完毕)后,主线程才结束。（这个我python用threading模块测试过了主线程是会等待子线程结束才结束进程的）



### 为什么线程池中线程可以复用？

线程在进入Stopped状态后, 就会被销毁, 是不可能再次Start的.要再次Start只能重新建立一个。
但为什么线程池中线程却可以重复利用呢,如果线程池中线程也是执行完任务后进入Stopped状态, 下次再新建并Start的话,很显然那就不叫线程池了.
所以, 线程池中的线程在执行完任务后,并没有进入Stopped状态,实际上线程池线程实际上是利用类似WaitHandle.WaitOne 方法在指定句柄上等待,直到有新任务到来.执行完后就再次等待。
