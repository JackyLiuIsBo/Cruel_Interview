## 一、写在前面

今天主要来复习和学习各种设计模式。

## 二、设计模式

> 参考链接：https://blog.csdn.net/tu_wer/article/details/120192797

### 1、如何分类

分类如下：

- 创建型模式（即输入参数为空，**创造**并返回一个新对象）
  - [x] 单例模式
  - [x] 工厂模式（简单工厂模式和抽象工厂模式）
  - [x] 原型模式
  - [x] 建造者模式
- 结构型模式（输入一个主体类，或以组合的方式包含一个主体类，返回一个**增强**后的主体类）
  - [x] 适配器模式
  - [ ] 桥接模式
  - [x] 装饰者模式
  - [ ] 组合模式
  - [x] 外观模式
  - [ ] 享元模式
  - [ ] 代理模式
- 行为型模式（）
  - [x] 模板方法模式
  - [ ] 命令模式
  - [ ] 访问者模式
  - [ ] 迭代器模式
  - [ ] 观察者模式
  - [ ] 中介者模式
  - [ ] 备忘录模式
  - [ ] 解释器模式
  - [ ] 状态模式
  - [ ] 策略模式
  - [ ] 职责链模式

### 1、工厂模式

定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

优点：

1. 一个调用者想创建一个对象，只要知道其名称就可以了。
2. 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。
3. 屏蔽产品的具体实现，调用者只关心产品的接口。

**常用命名类**：`XxxFactory`

```java
CarFactpory.produce("aodi"); //生成一辆奥迪车 
CarFactpory.produce("bmw"); //生成一辆宝马车 
```



### 2、建造者模式

一步一步创建一个复杂的对象，允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节

四个角色

产品角色(Product)：具体的产品对象
抽象建造者(Builder)：创建 Product 对象的各个部件指定的接口/抽象类
具体建造者(ConcreteBuilder)：实现接口，构建和装配各个部件
指挥者/经理(Director)：构建使用 Builder 接口的对象。主要是用于创建复杂的对象

**常用命名类**：`XxxBuilder`

```java
XxxBuilder.WithA("a").WithB("b") // 生成一个XXX，先构造一个A部件，然后在构造一个B部件，最后生成
```



### 3、适配器模式

将某个类的接口转换成客户端期望的另一个接口表示，主要目的是**兼容性**，让原本因接口不匹配，不能一起工作的两个类可以协同工作

客户端可以通过适配器，有选择地使用目标接口的方法(不是全部方法)(接口适配器)

分为：

- 类适配器
  - 适配器**继承**了目标对象类（类的继承）
- 对象适配器
  - 适配器中**聚合**了目标对象（类的组合）
- 接口适配器
  - 适配器定义为抽象类，具体的抽象类**实现**该接口，为该接口中每个方法提供一个**默认实现(空方法)**，那么客户端作为该抽象类(适配器)的子类可**有选择地覆盖父类的某些方法**来实现需求



### 4、装饰器模式

> 名词：抽象主体，具体主体（被装饰者），装饰者。

主体类和修饰类都要实现相同的方法。

Java等，类层面：传入一个主体类，做修饰后

Go，函数层面：传入一个函数签名为myFunc的函数，，

**常用命名**：

1、类：Java等语言中：功能+主体名。比如功能是过滤Filter，主体是`InputStream`，所以可以叫FilterInputStream

2、函数：Go语言或其他语言中，Wrap+功能。比如`WrapLogger`，来给主体函数的功能做加强，返回的依旧是主体函数的签名。

### 5、外观模式

> 名词：Facade

- 通过定义一个一致的接口，用以**屏蔽内部子系统的细节**，使得调用端只需关心这个接口的调用，而无需关心子系统的内部细节
- 解决多个复杂接口带来的使用困难，起到**简化用户操作**的作用

**常用类名：**`XxxFacade`

### 6、模板方法模式

- 先定义一个抽象类（父类），并在其中**定义操作中的算法的骨架**，而将一些步骤的具体实现延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤。
- 一般模板方法都加上 **final** 关键字，防止子类重写模板方法

常常可以和建造者模式结合起来使用。（因为建造者模式往往是有固定的建造步骤的，可以建成模板）

> 举个例子：
>
> 制作豆浆的流程是固定的：选材--->添加配料--->浸泡--->放到豆浆机打碎。因此可以固定成模板，做抽象父类`SoybeanMilk`，并且定义这几个抽象方法（或者不定义成抽象方法了，而是定义成实现一些固定的操作的方法），并且定义一个final方法make()，其中就是依次执行这几个方法。
>
> 通过添加不同的配料，可以制作出不同口味的豆浆；选材、浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的。
>
> 比如我想搞个红豆豆浆，可以创建子类`RedSoybeanMilk`，并且重写`配料()`方法，然后依旧是调用make即可。

> 钩子方法：
>
> 在模板方法模式的父类中，定义一个方法，**默认不做任何事，子类可以视情况要不要覆盖它**，该方法称为**钩子方法**
>
> “钩子方法:由抽象类声明并且实现,子类也可以选择加以扩展。通常抽象类会给出一个空的钩子方法,也就是没有实现的扩展。它和具体方法在代码上没有区别,不过是一种意识的区别;而它和抽象方法有时候也是没有区别的,就是在子类都需要将其实现的时候。而不同的是抽象方法必须实现,而钩子方法可以不实现。也就是说钩子方法为你在实现某一个抽象类的时候提供了可选项,相当于预先提供了一个默认配置。”
>
> 对于上述豆浆例子来说，比如我想制作原味纯豆浆，不添加任何的配料。（其实就是我介绍制作豆浆流程里面带括号的那种方案）



### 7、命令模式

- **消除了 请求发送者 与 请求接收者 之间的耦合**，让对象之间的调用关系更加灵活，实现解耦
- 在命令模式中，会将一个**请求封装为一个对象**，以便使用不同参数来表示不同的请求(即命名)，同时命令模式也**支持可撤销操作**

- 将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的 execute()方法就可以让接收者工作，而不必知道具体的接收者对象是谁、是如何实现的，命令对象会负责让接收者执行请求的动作，也就是说：”请求发起者”和“请求执行者”之间的解耦是通过命令对象实现的，命令对象起到了纽带桥梁的作用


- 空命令也是一种设计模式，省去了判空的操作



### *、易混模式组合

#### 1、工厂模式、建造者模式

> 参考链接：https://www.cnblogs.com/vigorz/p/10501934.html

> 一句话总结：工厂模式关心整体，建造者模式关心细节。

工厂方法模式注重的是**整体对象的创建方法**，而建造者模式注重的是**部件构建的过程**，旨在通过一步一步地精确构造创建出一个复杂的对象。

工厂模式是客户端直接传入字符串，然后去工厂里取对应产品。

建造者模式更加的Flexible and expressive，由客户端一步一步组装出一个对象。

#### 2、装饰器模式、代理模式

> 参考链接：https://www.cnblogs.com/yanggb/p/10952843.html

共同点：

1. 都是在代理类或装饰类中，以组合而不是继承的方式包含着主体类（原类）。

2. 都不多不少的需要实现原主体类中的方法。

   即：对装饰器模式来说，装饰者（Decorator）和被装饰者（Decoratee）都实现一个接口。对代理模式来说，代理类（Proxy Class）和真实处理的类（Real Class）都实现同一个接口。此外，不论我们使用哪一个模式，都可以很容易地在真实对象的方法前面或者后面加上自定义的方法。

不同点：

> 一句话答案：代理类，输入无参，返回一个新的代理类对象；装饰类，输入主体类，返回主体类（只不过类方法中增强了某些功能）

装饰器模式关注于在一个对象上动态地添加方法，而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类可以对它的客户隐藏一个对象的具体信息。因此当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例；当使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰器的构造器。

装饰器模式和代理模式的使用场景不一样，比如IO流使用的是装饰者模式，可以层层增加功能。而代理模式则一般是用于增加特殊的功能，有些动态代理不支持多层嵌套。

代理模式注重的是对对象的某一功能的流程把控和辅助，它可以控制对象做某些事，重心是为了借用对象的功能完成某一流程，而非对象功能如何。装饰模式注重的是对对象功能的扩展，不关心外界如何调用，只注重对对象功能加强，装饰后还是对象本身

总之，

**对于代理类，如何调用**对象的某一功能是思考重点，而**不需要**兼顾对象的所有功能，因为代理类**本质返回的是新的对象**；

**对于装饰类，如何扩展**对象的某一功能是思考重点，同时也**需要**兼顾对象的其他功能，因为再怎么装饰，**本质也是对象本身**，要担负起对象应有的职责，被装饰者的职责一旦增加，作为装饰类也需要有相应的扩展，必然会造成编码的负担。

#### 3、适配器、外观、代理、命令、中介者

共同点：在 操作方 与 被 操作方 之间，都存在一个中间层

