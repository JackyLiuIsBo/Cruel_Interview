## 一、写在前面

今天继续**数据库**，准备把所有的锁给系统的捋一捋。

## 二、数据库

首先明确一点：锁的分类并不全是指锁的状态，有的指锁的特性，有的指锁的设计。

### 1、再谈乐观锁与悲观锁

其实，编程界的很多名词，都是对于同一问题的不同场景，为了提升性能与效率，降低延时和复杂度，而采用不同级别的处理方式，不同级别的策略，来起的名字。

比如乐观锁悲观锁，并不是说在CPU层面有两种方式，而是CPU只提供Lock这一个方法，对于不同的业务场景，为了提升性能，我们可以基于不同策略来写代码封装Lock以供使用。

如果当前场景中读多写少，则为了提高并发（因为可以多个线程一起读，但是不能一起写），我们采用**无锁机制**，用版本号字段等方式（见下节），来处理当前事务。**无锁机制**，依旧要保证事务等数据的正确。所以我们在做数据操作的时候，我们是乐观的认为不会有线程修改数据，但如果发现真的被修改了，我们需要采取失败重试等处理方式。也就是说，我们是乐观的看待对当前数据的操作，认为他不会同时被其他线程操作而采取的策略，但是万一“同时被其他线程操作”这个事情发生了，我们也要有对应的策略去处理。可能这种“异常”处理的方式比较耗时，但由于我们当前场景假设了读多写少，所以“异常”出现的几率较小，所以这种方式是最优的。

即乐观锁与悲观锁都是考虑全面的，完备的。只是针对不同场景提出的不同策略而已。这个不同策略可以归纳为，在不同的时间去考虑多线程并发带来的问题。详细来说，悲观锁是多线程竞争资源之前上锁，来解决这一问题；乐观锁是多线程竞争资源之后，如果发生了资源竞争则后者失败重试。

再简单一点的作区分：但凡是涉及到锁（Lock）了，那他就是悲观锁，因为乐观锁是无锁的，只是用一些非阻塞的机制去解决资源竞争的问题，并且乐观的认为出现“资源竞争”的可能性很小。

### 2、乐观锁的常用实现方式

1、版本号机制

表中增加一个`version`字段。每次`UPDATE`操作属性a的时候，把`version`放到where里做过滤，版本号对应的上的话，再`UPDATE`a字段并`version+1`。

> Q1：但是万一数据库更新的时候，a更新了，但是version还没更新就宕机了呢？
>
> A1：因为单次操作也默认是事务的方式，这种情况应该会有日志处理。

2、CAS算法

CAS即 compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步，所以也属于**非阻塞同步**（Non-blocking Synchronization）。CAS 算法涉及到三个操作数：

1. 需要读写的内存值 V(进程内存空间中的变量值)
2. 进行比较的值 A(当前线程寄存器中的变量值)
3. 拟写入的新值 B(要更新的新值)

当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作（比较和替换是一个 native 原子操作）。一般情况下，这是一个自旋操作，即不断的重试，看下面流程：

> 关于ABA问题：https://blog.csdn.net/weixin_39640911/article/details/111822751
>
> Q1：长话短说，CAS算法带来的ABA问题？以及解决办法？
>
> A1：但是如果内存值原来是A，后来变成了 B，然后又变成了 A，那么 CAS 进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。
>
> > 详细的（理解就好，可以不看）：在线程A进来时，读取到的值x为1。在A进行计算的时候线程B取到了x的值，然后更新为了2。然后线程C又取到x=2的值，进行C的计算后，然后得到结果为1 又将x的值修改为了1这个时候，线程A进行判断的时候，会认为在其计算过程中没有其他线程对x进行过操作，所以提交事务，跳出循环。这种ABA有的会产生影响，有的不会，如果没有影响，则甚至不需要考虑该问题。
>
> Q2：举一个有影响的例子？
>
> A2：银行转账场景，假定银行转账就是一个简单的CAS操作，对比余额旧值和当前值是否相同（即操作转账，先是读取账户余额，然后执行 CAS(origin,expect) ）。小z账户上有100元，想给小y转账100元，从A取款机上操作，因为网络原因卡住了，然后想去附近的B取款机上操作，转账成功了。（此时余额0元），这时候小m给小z转账100元并成功了（余额100），然后A取款机上网络恢复了（CAS算法检测100元没错），执行CAS(100,0)，转账成功（余额0元）。然后小m给小z发微信问收到100元了没，小z一查余额发现是0，摇了摇头。其实钱是去了小y账户上，因为毕竟发起了两次转账。这种情况虽然解释得通但并不合理，我们作为系统开发者，不能接受这种情况存在，我们期望的情况是，B取款机上已经转账成功了，A取款机发现环境变化了就停止操作。正是因为这种不合理的情况，我们才要着手解决这种ABA问题。
>
> Q3：构成ABA问题的条件是什么？
>
> A3：构成 ABA 问题有三个重要的条件：
>
> 1. 某个线程需要重复读某个内存地址，并以内存地址的值变化作为该值是否变化的唯一判定依据；
> 2. 重复读取的变量会被多线程共享，且存在『值回退』的可能，即值变化后有可能因为某个操作复归原值；
> 3. 在多次读取间隔中，开发者没有采取有效的同步手段，比如上锁。
>
> 以上三个关键点构成了 ABA 问题的充要条件，我们只需要打破其中一个条件就可以解决 ABA 问题。
>
> Q4：如何解决ABA问题？
>
> A4：破坏三个条件中的任意一个都可以。比如”添加版本号“，可以破坏前两个条件；“加锁”，可以破坏第三个条件。但是“加锁”会大大增加系统可用性的风险，就上述案例而言，小z在发现 A取款机网络拥塞的时候，即便转到 B 去操作转账，也需要等待 A 执行完，完全释放锁才可以。

CAS的三大问题：ABA问题，循环时间长开销大，只能保证一个共享变量的原子操作。

## 2、悲观锁的常用实现方式



## 3、共享锁和排他锁

两种锁只是一种概念。（常常在读写数据库的时候使用？）

**共享锁（S锁）：**该锁可以被多个线程所持有。如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。

**排他锁（X锁）：**也叫独享锁，该锁一次只能被一个线程所持有。如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。

即共享锁下其它用户可以并发读取，查询数据。但不能修改，增加，删除数据。达到资源最大程度的共享。

> Q1：既然共享锁可以让多个线程同时访问加锁的内容，那又何必去加锁？
>
> A1：此处加锁，其实是为了防止该数据被进一步加排他锁。
>
> Q2：共享锁的应用场景？
>
> A2：运用在限制访问公共资源的线程数量，可以用来做流量的限制。比如说服务器同时登陆在线人数，比如说数据库连接池。

### 4、Java互斥锁与读写锁

如果说共享锁/排他锁就是一种概念，那么互斥锁/读写锁就是Java的具体的实现。

**互斥锁**的具体实现就是synchronized、ReentrantLock。ReentrantLock是JDK1.5的新特性，采用ReentrantLock可以完全替代替换synchronized传统的锁机制，更加灵活。

**读写锁**的具体实现就是读写锁ReadWriteLock。

### 5、可重入锁

> https://blog.csdn.net/u013713637/article/details/116132045
>
> go的设计者认为使用可重入锁是一种彻彻底底的错误，它是bug的温床，如果需要重入锁，就说明你的代码写的有问题。因为正常锁只有一个任务，所以不需要重入锁。
>
> https://studygolang.com/topics/6139
>
> 可以将代码按照作用范围分层，金字塔形，底部是各个小函数，上层调用下层的函数，越往上作用范围越大；各层有自己的锁，并只能在本层的函数中使用：同一个锁在不同层中使用就会导致重入。
>
> go的标准库里面的做法是将需要锁住的操作独立为函数`并以Locked为后缀命名`，然后在调用这些函数的地方用锁来保护。

可重入锁也是一个概念，作用在于避免死锁。

定义：对于同一个线程在外层方法获取锁的时候，在进入内层方法时也会自动获取锁。

Java中的`Synchronized`和`ReentrantLock`都是可重入的，指的是在一个线程中可以多次获取同一把锁，比如：

一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，而无需重新获得锁.

> Q1：如果让你自己实现一个可重入锁，你要注意哪些关键点？
>
> A1：两个关键点。第一个是**重复进入**。当前线程本次获取锁之后，下次在获取改锁的时候，判断为当前线程则直接进入，不阻塞。第二个是**锁的释放**。如果线程进入了n次，那么它只有释放n次之后，才是真正的释放锁。 因此对于一个不可重入锁，我们进行如下改造即可：
>
> - 获取锁时，需要判断当前锁是否被占用，如果没有被占用则获取，否则判断是否是当前线程占用，如果是则计数加1，否则等待锁释放。
> - 锁的释放，锁释放时要判断是否是当前线程，如果是，则计数减1，直到为0 ，才是真正释放锁
>
>  如果你想看Java版的具体代码实现，可以参考：[链接](https://www.zhihu.com/question/23284564)
>
> 如果想看Java版ReentrantLock锁，加锁和释放锁的次数不一致导致的死锁问题，可以看代码：[链接](https://blog.csdn.net/w8y56f/article/details/89554060)

**公平锁：**多个线程相互竞争时要排队，多个线程按照申请锁的顺序来获取锁。

**非公平锁：**又称竞争锁，多个线程相互竞争时，先尝试插队，插队失败再排队，比如：synchronized、ReentrantLock

一般可以通过参数来设置某个锁是公平锁还是非公平锁

### 7、分段锁

分段锁并不是具体的一种锁，只是一种锁的设计。

分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。拿Java来说，CurrentHashMap底层就用了分段锁，使用Segment，就可以进行并发使用了，而HashMap确实非线程安全的，就差在了分段锁上。

### 8、偏向锁、轻量级锁、重量级锁

JDK 1.6 为了减少获得锁和释放锁所带来的性能消耗，在JDK 1.6里引入了4种锁的状态：**无锁、偏向锁、轻量级锁和重量级锁**，它会随着多线程的竞争情况逐渐升级，但不能降级。

研究发现大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了不让这个线程每次获得锁都需要CAS操作的性能消耗，就引入了偏向锁。当一个线程访问对象并获取锁时，会在对象头里存储锁偏向的这个线程的ID，以后该线程再访问该对象时只需判断对象头的Mark Word里是否有这个线程的ID，如果有就不需要进行CAS操作，这就是偏向锁。当线程竞争更激烈时，偏向锁就会升级为轻量级锁，轻量级锁认为虽然竞争是存在的，但是理想情况下竞争的程度很低，通过自旋方式等待一会儿上一个线程就会释放锁，但是当自旋超过了一定次数，或者一个线程持有锁，一个线程在自旋，又来了第三个线程访问时（反正就是竞争继续加大了），轻量级锁就会膨胀为重量级锁，重量级锁就是Synchronized,重量级锁会使除了此时拥有锁的线程以外的线程都阻塞。

> 疑问：这个都是JVM中实现的吗？
>
> 解答：应该是的。详情可以看https://www.cnblogs.com/code-duck/p/13785044.html。里面说了偏向锁的判定逻辑，以及如何撤销偏向锁，如何关闭偏向锁。



### 10、哪些锁可以看成是元锁，可以实现出其他锁来？

元锁是我自己定义的一个词汇，意思是编程语言封装好的CPU指令级别的上锁操作，并且其他锁都可以在元锁的基础上实现。

我在学多并发，锁，这块知识的时候，一直在想这个问题，这么多锁，哪些是我可以自己实现的？哪些是必须用编程语言自带的库才能实现的？（因为自带的标准库封装了CPU指令级别的操作）

现在来一一总结。

> 对于Java来说，锁机制基本上就是关键字`synchronized`、和JDK1.5的新特性的`ReentrantLock`来搞定的。



乐观锁不是锁，是一种策略或算法。其他的都是悲观锁。

对于悲观锁，只需要掌握读写锁就行了：

对于读写锁：

> Java读写锁ReentrantReadWriteLock中的读锁ReadLock是共享锁，写锁WriteLock是排他锁。

1）多个读者可以同时进行读
2）写者必须互斥（只允许一个写者写，也不能读者写者同时进行）
3）写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）

互斥锁类似于读写锁中的写锁。

> 自旋锁：一次只能有一个**进程**进入临界区，读写锁是自旋锁的一个特例

### 11、具体应用场景

队列操作中：

线程A对队列负责将数据写入队列。须采取“互斥锁”或“读写锁的写锁”

线程B队列负责从队列读出数据。须采取“互斥锁”或“读写锁的写锁”，读队列操作，**不可采取“读写锁的读锁”**，因为从队列读出数据时，需要更改队列本身的下标索引，如果多个线程同时操作该队列的话，就会导致队列下标索引混乱。



### 12、synchronized和ReentrantLock的缺点

如果是Java岗位，那么也需要了解一下这个：

synchronized的缺点：

- 锁的释放情况少，只在程序正常执行完成和抛出异常时释放锁；
- 试图获得锁是不能设置超时；
- 不能中断一个正在试图获得锁的线程；
- 无法知道是否成功获取到锁；

ReentrantLock的缺点：

- 需要使用import 引入相关的Class；
- 不能忘记在finally 模块释放锁,这个看起来比synchronized 丑陋；
- synchronized可以放在方法的定义里面, 而reentrantlock只能放在块里面. 比较起来, synchronized可以减少嵌套；

