## 一、写在前面

今天来聊聊**B树和B+树**。

### 二、B树和B+树

> 参考博客：http://blog.codinglabs.org/articles/theory-of-mysql-index.html
>
> （备用链接：https://blog.csdn.net/wufuhuai/article/details/79631466）

### 1、描述一下B树

为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构：

d为大于1的一个正整数，称为B-Tree的度。

h为一个正整数，称为B-Tree的高度。

每个非叶子节点由n-1个key和n个指针组成，其中d<=n<=2d。

每个叶子节点由n-1个key和n个指针组成，其中2<=n<=2d，叶节点的指针均为null 。

所有叶节点具有相同的深度，等于树高h。

key和指针互相间隔，节点两端是指针。一个节点中的key从左到右非递减排列。每个指针要么为null，要么指向另外一个节点。

所有节点组成树结构。

如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于v(key1)，其中v(key1)为node的第一个key的值。

如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于v(keym)，其中v(keym)为node的最后一个key的值。

如果某个指针在节点node的左右相邻key分别是keyi和keyi+1且不为null，则其指向节点的所有key小于v(keyi+1)且大于v(keyi)。

### 2、B树的一些性质

1、一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。

### 3、B树的插入删除

插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质。

> Q1：为什么 对于一棵m阶的B树，每个分支节点至少有【m/2】棵子树？
>
> A1：因为删除的时候可能会合并，小于【m/2】棵子树了就得合并了。而且之所以规定【m/2】不能太小，是因为每次分配一个节点内存就是一个页，所以太小的话降低了利用率。虽然插入的时候可能分裂，但是这倒是不影响。

### 4、B树的变种----B+树

B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。

与B-Tree相比，B+Tree有以下不同点：

每个节点的指针上限为2d而不是2d+1。

内节点不存储data，只存储key；叶子节点不存储指针。

### 5、B树的变种----B*树

在B+树基础上，为非叶子结点再增加指向兄弟的链表指针，将结点的最低利用率从1/2提高到2/3。

> Q：为什么可以增加利用率？
>
> A：
>
> B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据
>
> 复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父
>
> 结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；
>
> B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分
>
> 数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字
>
> （因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之
>
> 间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；
>
> 所以，B*树分配新结点的概率比B+树要低，空间使用率更高；

**使用场景：**

有两种适合使用B*树索引的方法，
1）仅通过索引回答一个查询
索引包含了足够的信息来回答整个查询，根本不用去访问表。在这种情况下，索引则用作一个“较瘦“版本的表。
2）通过读索引来访问表中的少部分行
此时应当只访问问表中很少的一部分行（只占一个很小的百分比）。如果需要通过索引访问大量的行，那么与全表扫描相比，通过索引反而要花更多时间。
这是因为，一方面，增加了读取索引本身的数据块的I/O，另一方面，索引按索引键的顺序存储，会按键的有序顺序进行访问，索引指向的块则随机地存储在堆中，因此通过索引访问表时，会执行大量分散、随机的I/O。



### 5、B树和B+树的区别

定义上的区别：

一棵m阶的B树的满足条件：

- 每个节点至多有m棵子树

- 根节点除外，其它每个分支节点至少有【m/2】棵子树

- 根节点至少有两棵子树（除非B树只包含一个节点）

- 所有叶子节点在同一层上，B树的叶子节点可以看成一种外部节点，不包含任何信息。

- 有j个孩子的非叶结点恰好有j-1个关键码key，关键码按递增次序排列。


  一棵m阶的B+树的满足条件：

- 和B树前三条一样

- 有 j 个子树的中间节点包含有 j 个关键码key（B 树中是 j-1 个），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。

- 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。

- 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。


|                | B树（平衡多路查找树）                  | B+ 树                                                        |
| -------------- | -------------------------------------- | :----------------------------------------------------------- |
| 特性           | 每个结点存储M/2到M个关键字             | 每个结点存储M/2到M个关键字                                   |
| 叶子结点       | 数据data域在每个非叶子节点和叶子结点中 | 所有非叶子结点没有data域，只有key。数据都在叶子节点，同时叶子节点之间还加了指针形成链表。（所有节点key都在子节点中存在） |
| 使用场景       | B树多用于做文件系统的索引。            | B+树多用于数据库中的索引。                                   |
| 关键字出现次数 | 所有关键字在整颗树中出现，且只出现一次 | 所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引，关键字出现多次 |
| 命中           | 非叶子结点可以命中                     | 总是到叶子结点才命中                                         |
| data域位置     | 保存在非叶子结点中                     | 保存在叶子结点中                                             |



==B+树相比B树的查询优势：==

> 没啥用的参考链接：https://www.cnblogs.com/xueqiuqiu/articles/8779029.html

1. b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；
2. b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；
3. 对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历



### 6、B树用作数据库索引

B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。

综上所述，用B-Tree作为索引结构效率是非常高的。



### 7、为什么数据库索引不用红黑树

因为数据库索引一般都很大，不会存在主存中，一般都存在在磁盘上，而磁盘IO是十分耗时的，因此我们要以“最小化磁盘IO次数”为目标。如果树的深度为h，则需要进行h次磁盘IO。刚刚说了，B树的阶通常超过100，因此h通常不超过3。因此只需要2次IO读取。（因为根节点常驻内存）

而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以虽然红黑树的I/O渐进复杂度也为O(h)，但是效率明显比B-Tree差很多。

B+树等可以在文件查找的时候每次只加载一个节点的内容存入内存来查找。（在设计的时候，一个节点的大小就是一个页）

红黑树在内存中查找非常块，但是如果在数据库和文件系统中，显然B树更优

### 8、为什么B+树比B树更适合做索引

B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小。d的公式通常可表示成：dmax=floor(pagesize/(keysize+datasize+pointsize))

由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。

而且：

因为在数据库中select常常不只是查询一条记录，常常要查询多条记录。比如：按照id的排序的后10条。如果是多条的话，B树需要做中序遍历，可能要跨层访问。而B+树由于所有数据都在叶子结点，不用跨层，同时由于有链表结构，只需要找到首尾，通过链表就能够把所有数据取出来了。

### 9、MyISAM和InnoDB存储引擎的索引实现

原文讲的太好了，这边做整理了直接看原文吧。

摘要几个帮助回忆的重要的点：

相同点：二者都是B+树作为底层实现。

不同点：

**MyISAM：**

在MyISAM中，叶节点的data域存放的是数据记录的地址。

在MyISAM中，索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。

在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。

MyISAM的索引方式叫做“非聚集索引”

**在MyISAM中的取数据方式**：MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。



**InnoDB：**

在InnoDB中，数据文件本身就是索引文件，即表数据文件本身就是按B+Tree组织的一个索引结构，叶节点data域保存了完整的数据记录，用数据表的主键作为该索引的key。（所以InnoDB要求表必须有主键）

在InnoDB中，表数据文件本身就是主索引。

在InnoDB中，辅助索引data域存储相应记录主键的值而不是地址。即InnoDB的所有辅助索引都引用主键作为data域。

InnoDB的索引方式叫作“聚集索引”

**在InnoDB中的取数据方式**：**对于主键**的搜索十分高效，按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值即可。但**对于辅助索引**搜索时，需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。



> 了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助：
>
> 例子1：知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。
>
> 例子2：用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。



==MySQL查询数据时，多用主键查询和 通过unique约束的字段查询。==

> 没啥用的参考链接：https://blog.csdn.net/zhuanzhe117/article/details/78039692

### 10、MyISAM和InnoDB存储引擎的区别

1、MyISAM是非事务安全的，而InnoDB是事务安全的

2、MyISAM锁的粒度是表级的，而InnoDB支持行级锁

3、MyISAM支持全文类型索引，而InnoDB不支持全文索引

4、MyISAM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyISAM

5、MyISAM表保存成文件形式，跨平台使用更加方便

6、MyISAM管理非事务表，提供高速存储和检索以及全文搜索能力，如果在应用中执行大量select操作可选择

7、InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量insert和update操作，可选择。

### 11、索引分为聚簇索引和非聚簇索引两种

> 聚集索引（Clustered Index，也称聚类索引、簇集索引、聚簇索引）
>
> 非聚集索引（Nonclustered Index，也称非聚类索引、非簇集索引）

聚簇索引 是按照数据存放的物理位置为顺序的，而非聚簇索引就不一样了；聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索很快。

通常MyISAM的主索引和InnoDB的第二索引都算是非聚簇索引。

### 12、B+树的一个节点的大小是多大？

一个节点的大小是1页，linux中是16k。

### 13、InnoDB如果没有主键，怎么定义聚簇索引？

Innodb通过主键聚集数据，如果没有定义主键，innodb会选择非空的唯一索引代替。如果没有这样的索引，innodb会隐式的定义一个主键来作为聚簇索引。

### 14、非主键索引在什么情况下不进行回表？

如果覆盖索引就不需要回表了。索引覆盖是指，在一次查询中，一个索引（往往是组合索引）覆盖了所有要查询的字段。

> 可以通过explanation sql语句，看extra字段的结果是否为Using index来查看是否是覆盖索引。



















