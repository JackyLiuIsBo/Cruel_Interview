## 一、写在前面

继续**MYSQL**。

## 二、语言层面

python的变量

```python
>>> a=1
>>> id(a)
140711975048224
>>> a+=2
>>> id(a)
140711975048288
```

go的变量

```go
例一：
	x := 1
    fmt.Printf("%p\n",&x) //0xc0000140a8
    x += 2
    fmt.Printf("%p\n",&x) //0xc0000140a8

例二：
    arr := [2]int{1, 2}
    res := []*int{}
    for _, v := range arr {
        res = append(res, &v)
    }
    //expect: 1 2
    fmt.Println(*res[0],*res[1])
    //but output: 2 2
//例二的解释：for-range 其实是语法糖，内部调用还是 for 循环，初始化会拷贝带遍历的列表(如 array，slice，map)，然后每次遍历的v都是对同一个元素的遍历赋值。也就是说如果直接对v取地址，最终只会拿到一个地址，而对应的值就是最后遍历的那个元素所附给v的值。对
```

解释：

因为python中，解释器在运行时无法确定a的类型，所以每次在给a赋值的时候，都会改变地址。虽然对于这种字面量，依旧是值而不是引用。

go等编译型语言中，这种在栈中分配的变量，分配之后，生存周期结束之前，变量所绑定的地址是不变的。





## 三、MySQL

### 1、mysql中如何手动处理事务

mysql是默认开启 事务的自动提交 的。因此首先要关闭自动提交。

事务不需要关闭，不开启事务，则就是关闭事务。

```sql 
set autocommit = 0 -- 默认为1，开启。
```

然后手动处理事务：

```sql
-- 事务开启
start transaction
insert	。。。
insert。。。
commit -- 提交，成功则持久化到硬盘

rollback -- 回滚，失败则回到原来的样子
-- 事务结束后别忘了再开启自动提交

```

关于保存点（了解即可）

```sql
-- 了解，基本不用的，保存点。
savepoint XXX -- 设置一个事务的保存点
rollback to savepoint XXX -- 回滚到保存点
release savepoint XXX -- 撤销保存点
```



### 2、索引

==MySQL查询数据时，多用主键查询和 通过unique约束的字段查询。==



**索引是**帮助mysql高效获取数据的**数据结构**。创建索引的过程，就是在内存中又给他建立了一棵树。

#### 2.1、为什么使用索引

因为索引可以帮助MySQL高效的获取数据。

#### 2.2、索引的分类 

- 主键索引（primary key）
  - 唯一的标识，主键不可重复，只能有一个主键索引（但是可以有多个列做组合？）
- 唯一索引（unique key）
  - 被设置唯一索引的列中，列值必须唯一，且允许有空值。可以标识多个列为唯一索引。
  - 不允许具有索引值相同的行，从而禁止储存的数据结构中重复的索引或键值（例如B树中）
- 常规索引（key或者index）
- 全文索引（FullText）
  - 可以快速定位数据

唯一索引中的"唯一"指的是字段唯一，并不是说这个索引在一个表中只能出现一次。通过创建唯一索引，可以保证某一列的值具有唯一性。所以广义来讲，主键索引也是一种唯一索引。





总结：在一个表中，主键索引只能有一个，唯一索引可以有多个

#### 2.3、怎么使用索引

```sql
-- 数据库中 查询索引信息
show index from 表名
-- 增加一个全文索引
alter table `数据库.表名` add fulltext index 索引名(具体绑定的列)
-- 增加一个普通索引，索引名规范命名为：id_表名_字段名
create index 索引名 on 表(字段)

-- 用explain语句来查看select详细过程
explain select * from student where id = 2
```

每个索引都有自己的名字，sql中除了主键的，其他的都需要写。



#### 2.4、什么情况下索引失效

- where中对索引列进行计算或者使用函数时;（select * from student where id=id+1 and abs(id)=1）

- 在where语句中使用or时,如果有一个列没索引,那么其他列就会失效。即有or必全有索引才生效。==解决方法：使用union代替or==

  > 关于union：
  >
  > UNION 操作符用于**合并**两个或多个 SELECT 语句的结果集。
  >
  > 请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。
  >
  > UNION：直接取并集，即append起来再去重。
  >
  > UNION ALL：只append起来，即左右表都有的会显示多次
  >
  > ```sql
  > SELECT column_name(s) FROM table_name1
  > UNION
  > SELECT column_name(s) FROM table_name2
  > ```

- like以%开头

- 需要类型转换时（比如列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引，即要养成sql规范的习惯！）

- 复合索引未用左列字段

#### 2.5、索引原则

- 索引不是越多越好（数据量500w之后再考虑），数据少时，mysql认为全表扫描更快。

- 不要对经常变动(频繁更新)的数据加索引。
  - 比如logincount登录次数，频繁变化导致索引也频繁变化，增大数据库工作量，降低效率。
- 数据唯一性差（一个字段的取值只有几种时）的字段不要使用索引。
  - 比如性别，只有两种可能数据。意味着索引的二叉树级别少，多是平级。这样的二叉树查找无异于全表扫描。
- 小数据量的表，不需要加索引。

- 索引一般加在用来查询的字段上。
  - 只有在where语句出现，mysql才会去使用索引
- 如果where后含IS NULL /IS NOT NULL/ like ‘%输入符%’等条件，不建议使用索引
- 索引使用<>时，效果一般
- innoDB默认数据结构是BTree



#### 2.6、为什么索引会有“最左前缀匹配原则”？ 

由于联合索引构建存储方式（[InnoDB联合索引的数据结构是什么?](https://www.cnblogs.com/frankcui/p/15312279.html)）是根据第一个索引列“单调递增”排序，如果第一列相等则再根据第二列单调递增排序，依次类推。。。也就是说，对于(b,c,d)联合索引来说，相当于创建了(b)、（b、c）（b、c、d）三个索引

![image-20220212142216034](D:\mystudy\internship\Cruel_Interview\participants\zhaoxinzhi\assets\2022_01_30\image-20220212142216034.png)

索引的第一列也就是b列可以说是从左到右单调递增的，但我们看c列和d列并没有这个特性，它们只能在b列值相等的情况下这个小范围内递增，所以如果你的查找条件不包含b列如（c,d）、(c）、(d)是无法应用缓存的，以及跨列也是无法完全用到索引如(b,d)，只会用到b列索引。



#### 2.7、为什么尽量在InnoDB上采用自增字段做主键

InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。

如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图：

![image-20220212143137283](D:\mystudy\internship\Cruel_Interview\participants\zhaoxinzhi\assets\2022_01_30\image-20220212143137283.png)

这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。

如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：

![image-20220212143154401](D:\mystudy\internship\Cruel_Interview\participants\zhaoxinzhi\assets\2022_01_30\image-20220212143154401.png)

此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。

因此，只要可以，请尽量在InnoDB上采用自增字段做主键。
