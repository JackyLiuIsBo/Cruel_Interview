## 一、写在前面

继续**MYSQL**。

## 二、语言层面

python的变量

```python
>>> a=1
>>> id(a)
140711975048224
>>> a+=2
>>> id(a)
140711975048288
```

go的变量

```go
例一：
	x := 1
    fmt.Printf("%p\n",&x) //0xc0000140a8
    x += 2
    fmt.Printf("%p\n",&x) //0xc0000140a8

例二：
    arr := [2]int{1, 2}
    res := []*int{}
    for _, v := range arr {
        res = append(res, &v)
    }
    //expect: 1 2
    fmt.Println(*res[0],*res[1])
    //but output: 2 2
//例二的解释：for-range 其实是语法糖，内部调用还是 for 循环，初始化会拷贝带遍历的列表(如 array，slice，map)，然后每次遍历的v都是对同一个元素的遍历赋值。也就是说如果直接对v取地址，最终只会拿到一个地址，而对应的值就是最后遍历的那个元素所附给v的值。对
```

解释：

因为python中，解释器在运行时无法确定a的类型，所以每次在给a赋值的时候，都会改变地址。虽然对于这种字面量，依旧是值而不是引用。

go等编译型语言中，这种在栈中分配的变量，分配之后，生存周期结束之前，变量所绑定的地址是不变的。





## 三、MySQL

### 1、mysql中如何手动处理事务

mysql是默认开启 事务的自动提交 的。因此首先要关闭自动提交。

事务不需要关闭，不开启事务，则就是关闭事务。

```sql 
set autocommit = 0 -- 默认为1，开启。
```

然后手动处理事务：

```sql
-- 事务开启
start transaction
insert	。。。
insert。。。
commit -- 提交，成功则持久化到硬盘

rollback -- 回滚，失败则回到原来的样子
-- 事务结束后别忘了再开启自动提交

```

关于保存点（了解即可）

```sql
-- 了解，基本不用的，保存点。
savepoint XXX -- 设置一个事务的保存点
rollback to savepoint XXX -- 回滚到保存点
release savepoint XXX -- 撤销保存点
```



### 2、索引

**索引是**帮助mysql高效获取数据的**数据结构**。创建索引的过程，就是在内存中又给他建立了一棵树。

#### 2.1、为什么使用索引

因为索引可以帮助MySQL高效的获取数据。

#### 2.2、索引的分类 

- 主键索引（primary key）
  - 唯一的标识，主键不可重复，只能有一个主键索引（但是可以有多个列做组合？）
- 唯一索引（unique key）
  - 被设置唯一索引的列中，列值必须唯一，且允许有空值。可以标识多个列为唯一索引。
  - 不允许具有索引值相同的行，从而禁止储存的数据结构中重复的索引或键值（例如B树中）
- 常规索引（key或者index）
- 全文索引（FullText）
  - 可以快速定位数据

唯一索引中的"唯一"指的是字段唯一，并不是说这个索引在一个表中只能出现一次。通过创建唯一索引，可以保证某一列的值具有唯一性。所以广义来讲，主键索引也是一种唯一索引。





总结：在一个表中，主键索引只能有一个，唯一索引可以有多个

#### 2.3、怎么使用索引

```sql
-- 数据库中 查询索引信息
show index from 表名
-- 增加一个全文索引
alter table `数据库.表名` add fulltext index 索引名(具体绑定的列)
-- 增加一个普通索引，索引名规范命名为：id_表名_字段名
create index 索引名 on 表(字段)

-- 用explain语句来查看select详细过程
explain select * from student where id = 2
```

每个索引都有自己的名字，sql中除了主键的，其他的都需要写。



#### 2.4、什么情况下索引失效

- where中对索引列进行计算或者使用函数时;（select * from student where id=id+1 and abs(id)=1）
- 在where语句中使用or时,如果有一个列没索引,那么其他列就会失效。即有or必全有索引。
- like以%开头
- 需要类型转换时（比如列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引，即要养成sql规范的习惯！）
- 复合索引未用左列字段

#### 2.5、索引原则

- 索引不是越多越好（数据量500w之后再考虑），数据少时，mysql认为全表扫描更快。

- 不要对经常变动(频繁更新)的数据加索引。
  - 比如logincount登录次数，频繁变化导致索引也频繁变化，增大数据库工作量，降低效率。
- 数据唯一性差（一个字段的取值只有几种时）的字段不要使用索引。
  - 比如性别，只有两种可能数据。意味着索引的二叉树级别少，多是平级。这样的二叉树查找无异于全表扫描。
- 小数据量的表，不需要加索引。

- 索引一般加在用来查询的字段上。
  - 只有在where语句出现，mysql才会去使用索引
- 如果where后含IS NULL /IS NOT NULL/ like ‘%输入符%’等条件，不建议使用索引
- 索引使用<>时，效果一般
- innoDB默认数据结构是BTree


