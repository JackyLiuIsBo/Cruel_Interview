## 一、写在前面

今天开始连续肝**数据库**相关知识。同时我打算从b站上系统的学一下MySQL。同时把面经整理下来。

## 二、数据库

### 一、事务及其特性

事务（Transaction）是一个操作序列，不可分割的工作单位，以BEGIN TRANSACTION开始，以ROLLBACK/COMMIT结束。

事务的ACID特性：

- **原子性**（Atomicity）：逻辑上是不可分割的操作单元，事务的所有操作要么全部提交成功，要么全部失败回滚（用回滚日志实现，反向执行日志中的操作）；
- **一致性**（Consistency）：事务的执行必须使数据库保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的；
- **隔离性**（Isolation）：一个事务所做的修改在最终提交以前，对其它事务是不可见的（并发执行的事务之间不能相互影响）。具体体现为不同的隔离级别。（一句话：即无法被其他事务干扰）
- **持久性**（Durability）：一旦事务提交成功，对数据的修改是永久性的

其实AID都是为了保证事务的一致性C。

## 二、事务会出现的一致性问题

由于事务的并发，难免会出现一些一致性问题。

- **丢失修改**：一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改；
- **脏读**（Dirty Read）：一个事务读取了被另一个事务修改、但未提交（进行了回滚）的数据，造成两个事务得到的数据不一致；
- **不可重复读**（Nonrepeatable Read）：在同一个事务中，某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改（针对**update**操作）；
- **幻读**（Phantom Read）：当同一查询多次执行时，由于其它事务在这个数据范围内执行了插入操作，会导致每次返回不同的结果集（和不可重复读的区别：针对的是一个数据整体/范围；并且针对**insert和delete**操作）

## 三、数据库的四种隔离级别

见`2022_01_09.md`

## 四、乐观锁与悲观锁

是指，对某一数据进行并发访问、资源竞争的时候，针对不同场景提出的不同的解决方案。

- 悲观锁：认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其它事务读取或修改数据；应用于**数据更新比较频繁**的场景；
- 乐观锁（无锁机制）：操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试；适用于**读多写少**的场景。乐观锁的实现方式有：
  - 版本号机制：加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段；
  - CAS算法：无锁算法，不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新。

