## 一、写在前面

今天我想详细的整理一下关于TCP/IP的一些知识点，可能面试的时候不会遇到原题的问法，但是这对加深对传输层整个流程的理解是没啥坏处的。

## 二、计算机网络-TCP/IP

### 1、端到端通信

端到端通信，由客户端端口+服务端端口+客户端IP+服务端IP+传输协议组成的五元组可以明确的标识一条连接。

socket网络编程就是端到端通信

> 在TCP/IP协议中，用“源IP地址”，“目的IP地址”，“源端口号”，“目的端口号”,协议号（IP协议的协议号为4，TCP的协议号为6）这样的一个五元组来标识一个通信，通信的双方在发送消息时，消息的头部会带着这样的五元组

### 2、一个TCP连接的具体含义

一个连接的唯一标识是`[server ip, server port, client ip, client port]`这个四元组。

操作系统，接收到一个端口发来的数据时，会在该端口，产生的所有socket连接中，查找到符合这个唯一标识的socket连接并传递信息到**对应**缓冲区。所以其实TCP连接和端口就没啥确切的对应关系。（比如一个端口只能一个TCP连接啦之类的）

所以缓冲区啊发送窗口啊接收窗口啊都是针对的一个TCP连接，而不是一个端口。

> 注意这句话这，接收缓冲区和发送缓冲区不是主机级别的。操作系统内核接收到网卡的数据包后，先**解包**，根据源IP和端口、目的IP和端口，找到对应socket连接，把TCP报文的**数据部分**放到对应socket连接中的接收缓冲区中，等待 绑定该端口的应用程序获取。
>
> 即每个套接字也有自己的缓冲区（写缓冲区和接收缓冲区），然后用户进程的接收缓冲区是另一个(即`char buff[1024]`这样)，然后去`socket.read()`套接字的缓冲区的内容。）



### 3、TCP连接接收到的数据一定来自同一主机吗？UDP呢？

> 链接https://www.cnblogs.com/jason2013/articles/4346639.html第三点

是的。TCP是面向连接的，也就是说，在连接持续的过程中，socket中收到的数据都是由同一台主机发出的（劫持什么的不考虑），因此，只要保证数据是有序的到达就行了，至于每次读取多少数据自己看着办。 

> 注意上面说**socket中收到的数据都是由同一台主机发出的**，指的是同一个socket连接（其实也就是指的TCP连接因为UDP没有连接），而不是同一个端口。所以发送窗口接收窗口啥的都是一个连接中的，而不是一个端口中的。所以“socket中收到的数据都是由同一台主机发出的”这句话是对的。
>
> 同一个端口中当然不一定收到的数据都是同一台主机发出的，因为一个端口可以建立多个socket连接（只要**四元组不同**（注意这里不是五元组）就算建立不同连接）
>
> 具体例子看[链接](https://blog.csdn.net/u011580175/article/details/80306414)
>
> 主要是这里：本地启用两个进程去访问服务端，服务端只用了一个进程，且只绑定了一个端口（虽然可以绑定多个，详见[端口](#jump)）
>
> ![image-20220111024506497](D:\mystudy\internship\Cruel_Interview\docs\打卡\zhaoxinzhi\assets\2022_01_11\image-20220111024506497.png)

而UDP是无连接的协议，也就是说，只要知道接收端的IP和端口，且网络是可达的，任何主机都可以向接收端发送数据。这时候，如果一次能读取超过一个报文的数据，则会乱套（例如主机A向发送了报文P1，主机B发送了报文P2，如果能够读取超过一个报文的数据，那么就会将P1和P2的数据合并在了一起，这样的数据是没有意义的。）

> Q1：TCP和UDP通信两端都需要socket，为什么TCP有连接，UDP无连接？
>
> A1：首先socket和连接没有关系，只是一个“通信端点”的抽象概念，而是否面向连接是有具体协议所定义的。。具体到编程中，TCP需要先connect建立连接，再read/write；而UDP socket之后直接read/write

### 4、端口究竟是什么？<span id="jump">1</span>



> win10系统进程端口相关命令[链接](https://baijiahao.baidu.com/s?id=1706693631469695476)
>
> 常用：`netstat -ano`查看所有端口占用情况
>
> ![image-20220111015312705](D:\mystudy\internship\Cruel_Interview\docs\打卡\zhaoxinzhi\assets\2022_01_11\image-20220111015312705.png)
>
> ![image-20220111015654700](D:\mystudy\internship\Cruel_Interview\docs\打卡\zhaoxinzhi\assets\2022_01_11\image-20220111015654700.png)

Q1：每个进程一定占用端口吗？

A1：只有与网络有关的进程才需要占用端口号,一般的应用进程是不需要占用的,比如你打开个gedit或者vim之类的应用进程就不会占用任何端口号

Q2：一个进程是否可以bind多个端口号？

A2：可以。因为一个进程可以打开多个文件描述符，而每个文件描述符都对应一个端口号，所以一个进程可以绑定多个端口号。（如上图，可以发现`pid=8852`这个进程绑定了很多TCP连接，对应本地很多端口号）

Q3：一个端口是否可以bind给多个socket吗？

A3：不能。一个端口同一时间只能bind给一个SOCKET。就是同一时间一个端口只可能有一个监听线程(监听listen之前要bind)

Q4：一个端口号是否可以被多个进程绑定？
A4：如果是同一个协议，不可以。（其实准确的说，父子进程可以，不同进程不可以。如果进程先绑定一个端口号，然后在fork一个子进程，这样的话就可以是实现多个进程绑定一个端口号，但是两个不同的进程绑定同一个端口号是不可以的。）如果是不同协议，是可以利用相同的端口号的？上层应用程序仍然可以对到来的数据进行解复用，因为它们对应的协议是不同的，比如两个应用程序都可以利用7000端口，但是一个采用TCP协议，另一个采用UDP协议，应该没有问题？

### 5、socket究竟是什么？

>  参考链接https://blog.csdn.net/liuxizhen2009/article/details/83716542或者[链接2](https://blog.csdn.net/zsxy309/article/details/6739262 )，建议多看。
>
> 一个指定的端口号不能被多个程序共用。比如，如果IIS占用了80端口，那么Apache就不能也用80端口了
>
> 很多防火墙只允许特定目标端口的数据包通过。
>
> 服务程序在listen某个端口并accept某个连接请求后，会生成一个新的socket来对该请求进行处理。

关于Socket编程，基本就是listen，accept以及send，write等几个基本的操作。是的，就跟常见的文件操作一样，只要写过就一定知道。

对于网络编程，我们也言必称TCP/IP，似乎其它网络协议已经不存在了。对于TCP/IP，我们还知道TCP和UDP，前者可以保证数据的正确和可靠性，后者则允许数据丢失。最后，我们还知道，**在建立连接前，必须知道对方的IP地址和端口号**。写服务程序的时候，会使用多线程来处理并发访问。

TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。在Socket编程接口里，设计者提出了一个很重要的概念，那就是socket。这个socket跟文件句柄很相似，实际上在BSD系统里就是跟文件句柄一样存放在一样的**进程句柄表**里。这个socket其实是一个序号，表示其在句柄表中的位置.

> 这一点，我们已经见过很多了，比如文件句柄，窗口句柄等等。这些句柄，其实是代表了系统中的某些特定的对象，用于在各种函数中作为参数传入，以对特定的对象进行操作--这其实是C语言的问题，在C++语言里，这个句柄其实就是this指针，实际就是对象指针啦。

**socket只是对TCP/IP协议栈操作的抽象**。socket跟TCP/IP并没有必然的联系。Socket编程接口在设计的时候，就希望也能适应其他的网络协议。所以，socket的出现只是可以更方便的使用TCP/IP协议栈而已，其对TCP/IP进行了抽象，形成了几个最基本的函数接口。比如create，listen，accept，connect，read和write等等。比如accept函数，其实抽象的是TCP的连接建立过程，等等。

如果一个程序创建了一个socket，并让其监听80端口，其实是向TCP/IP协议栈声明了其对80端口的占有。以后，所有目标是80端口的TCP数据包都会转发给该程序（这里的程序，因为使用的是Socket编程接口，所以首先由Socket层来处理）。accept函数返回的新socket其实指代的是本次创建的连接，而一个连接是包括两部分信息的，一个是源IP和源端口，另一个是宿IP和宿端口。所以，accept可以产生多个不同的socket，而这些socket里包含的宿IP和宿端口是不变的，变化的只是源IP和源端口。这样的话，这些socket宿端口就可以都是80，而Socket层还是能根据源/宿对来准确地分辨出IP包和socket的归属关系，从而完成对TCP/IP协议的操作封装。

### 6、浏览器，页面刷新，传输层层面发生什么？

会使得之前建立的TCP连接进入`TIME_WAIT`阶段，客户端重新发起TCP连接请求，服务端重新选择一个端口建立连接。

下图是我写了一个socket服务端程序监听本地8900端口，然后浏览器打开`127.0.0.1:8900`，过了一会刷新了页面，本地cmd中输入指令查看端口占用情况后，输出的结果：

![image-20220111023638475](D:\mystudy\internship\Cruel_Interview\docs\打卡\zhaoxinzhi\assets\2022_01_11\image-20220111023638475.png)



### 7、服务器收到TCP和UDP，分别会如何反应？

TCP,UDP是传输层的协议,TCP,UDP收到数据包后，会**根据数据包中指定的端口，发给该端口的进程**（注意每个端口只能绑定一个进程），而进程是通过SOCKET来接收发送数据的。（数据包是主机中TCP/IP协议栈拆分出数据送到对应进程的socket连接的缓冲区的呢，还是操作系统先找到对应socket连接放进去，由进程对应的代码中封装的系统调用再去拆包放入缓冲区的呢。。。。也就是说进缓冲区的时候是拆包(tcp首部啥的)之前还是之后的？）

服务器每接收到TCP包时，服务器的SOCKET会再产生一个SOCKET来表示本次连结。

服务器每接收到UDP包时，服务器的SOCKET会产生一个数据包，即datagram，来表示本次收到数据。

### 8、TCP为什么叫做流协议？

客户端发送字节流时，TCP会保证服务端**按顺序**接收到全部的字节流。之所以称为流协议，是因为我们收到512个字节的数据，不需要关心他们是否属于同一文件（不属于则发生了TCP粘包），也不需要关心具体是文件的第几个字节。

> 关于TCP的流模式协议，有个蓄水池的比喻：（可以不看）
>
> 你家里有个蓄水池，你可以里面倒水，蓄水池上有个龙头，你可以通过龙头将水池里的水放出来，然后用各种各样的容器装（杯子、矿泉水瓶、锅碗瓢盆）接水。 上面的例子中，往水池里倒几次水和接几次水是没有必然联系的，也就是说你可以只倒一次水，然后分10次接完。另外，水池里的水接多少就会少多少；往里面倒多少水，就会增加多少水，但是不能超过水池的容量，多出的水会溢出。 
> 结合TCP的概念，水池就好比接收缓存，倒水就相当于发送数据，接水就相当于读取数据。好比你通过TCP连接给另一端发送数据，你只调用了一次write，发送了100个字节，但是对方可以分10次收完，每次10个字节；你也可以调用10次write，每次10个字节，但是对方可以一次就收完。（假设数据都能到达）但是，你发送的数据量不能大于对方的接收缓存（流量控制），如果你硬是要发送过量数据，则对方的缓存满了就会把多出的数据丢弃。 这种情况是设置非阻塞I/O模型，会把内存耗尽，因为socket是存在内核中的。

因此TCP只是保证字节像水流一样源源不断的流入，没有具体的起始和截止字节的标识符。具体如何拼接这些字节数据，交由上层应用层（我们的应用程序）处理。

客户端发送数据只需要调用send函数，我们只需要关注send函数的返回值，从而知道了发送了多少个字节。

服务端接收数据只需要调用recv函数，我们只需要关注recv函数的返回值，从而知道接收了多少个字节。

其他诸如数据包的大小等，TCP协议对我们来说是透明的，我们不需要关心（也没法关心，但可以设置）数据包的大小，个数，我们只需要在客户端建立一个缓冲区不断发送，在服务端建立一个缓冲区不断接收就够了。

当然，我们还可以定义一个包头，来实现诸如发送文件这样更强大的功能。

### 9、什么是TCP粘包

> [链接1](https://blog.csdn.net/weixin_41047704/article/details/85340311) [链接2](https://www.cnblogs.com/kex1n/p/6502002.html) [链接3](https://blog.csdn.net/hik_zxw/article/details/48398935)

TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾，出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。

> TCP分为发送粘包和接收粘包：
>
> 发送粘包，是指应用程序一次发送的数据较小，TCP/IP协议栈采用了Negal算法优化，先将数据包缓存在socket发送缓冲区中，待数据包足够大时，再一次性发送。
>
> 接收粘包，是指应用程序接收端，一次从socket接收缓冲区中读出多个数据包，需要做粘包和半包处理。



> https://blog.csdn.net/hik_zxw/article/details/48896725
>
> UDP不存在粘包问题，是由于UDP发送的时候，不使用Negal算法优化，不会将多个小包合并一次发送出去。另外，在UDP协议的接收端，采用了链式结构来记录每一个到达的UDP包（TCP是流式的放到缓冲区中的所以），这样接收端应用程序一次recv只能从socket接收缓冲区中读出发送端发送的一个数据包。也就是说，发送端send了几次，接收端必须recv几次（无论recv时指定了多大的缓冲区）。

### 10、TCP和UDP代码模板

在代码中，实现TCP和UDP分别需要哪些步骤？

>体现在代码中，tcp socket连接过程：
>
>client: socket -> connect -> send/recv -> close
>server: socket -> bind -> listen -> accept -> recv/send -> close
>
>
>
>体现在代码中，udp socket连接过程：
>
>client: socket -> connect -> send/recv -> close
>
>server: socket -> bind -> recv/send -> close

### 11、Q&A

Q1：如果监听的线程释放掉监听用的SOCKET了，会影响之前通过这个监听SOCKET建立的TCP连接么？

A1：并不会，SOCKET之间是独立的，不会有影响

> https://blog.csdn.net/pyl88429/article/details/102814569
>
> Q2：一个端口是否在服务器上只能开一次？
> A2：跟网卡数目有关。一台电脑如果配置多个IP，则每个就可以绑定多个端口。如本机两个网卡IP分别为192.168.100.73和10.32.91.197，可以分别在这个两个网卡上开8000端口进行监听。
>
> Q3：作为服务端开启服务，为什么不指定监听在哪个IP上，客户端也能访问服务？
> A3：服务端在建立socket的时候，大多数情况是不需要指定本地服务器IP，而是使用INADDR_ANY，这样建立监听后本地所有网卡都可访问。原因是INADDR_ANY建立的监听会开在0.0.0.0这个IP上。**0.0.0.0这个IP代表的意思是该主机上所有IP地址。**
>
> Q4：能否在本地开个服务端口只有该主机才能访问呢？
> A4：可以，只要服务绑定的IP地址为127.0.0.1。这样只有本机能访问该服务端口
>
> Q5：能否在指定的几个IP上开通同一个端口监听呢？
> A5：可以，但每个IP要单独对应socket进行监听，无法做到类似INADDR_ANY，一个socket handle就可以监听所有IP。

Q6：UDP协议干了个啥？

A6：UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。

