## 一、写在前面

关于Hash，需要掌握些什么。

## 二、Hash

哈希，就是将一个无限集合映射到一个有限集，如果选择理想的hash函数，能够将预期处理到的元素均匀分布到有限集中即可在O(1)时间内完成元素查找。但理想的hash函数是不存在的，且由于映射的本质(无限到有限)必然出出现一个位置有多个元素要‘占据’，这就需要解决冲突。现有的解决冲突的方法：

1. 开放定址法
2. 链地址法
3. 多哈希函数法
4. 建域法



**开放定址法**：形成hash表时，某元素在第一次探测其应该占有的位置时，如果发现此处(记为A)已经被别人占了，那就在从A开始，再次探测(当然这次探测使用的hash函数与第一次已经不一样了)，如果发现还是被别人占了，那么继续探测，至到找到一个可用位置(也有可能在当下条件下永远找不到)。开放地址法有一个至关重要的问题需要解决，那就是在一个元素离开hash表时，如何处理离开后的位置状态。如果设置为原始空状态，那么后续的有效元素就无法识别了，因为在查找时同样是依据上面的探测规则进行查找，所以必须告诉探测函数某个位置虽然无有效元素了，但后续的探测可能会出现有效元素。我们可以发现，开放定址法很容易发生冲突(主要是一次探测以上成功的元素占取其它元素应该在第一次探测成功的位置)，所以就需要加大hash有效空间。

**链地址法**：链地址法的思想很简单，你不是可能会出现多个元素对应同一个位置，那么我就在这个位置拉出一个链表来存放所以hash到这个位置的元素。很简单吧，还节约内存呢！很遗憾，python的设计者没有选它。

**建域法**：基本思想为假设哈希函数的值域为[0,m-1],则设向量HashTable[0..m-1]为基本表，另外设立存储空间向量OverTable[0..v]用以存储发生冲突的记录。

> python发明者选择了开放定址而不是链地址法：
>
> 由于链地址法需要动态的生成链表结点(malloc)，所以时间效率不如开放定址法（但开放定址法的装载率不能高于2/3，相对于链地址法的空间开销也是毋庸置疑的），由此可以看出python的设计时代已经不是那个内存只有512k可供使用的时代了，对内存的苛刻已经让步于效率。当然这需要考虑到python由于实现动态而必须靠自身的设计将损失的时间效率尽可能地补回来。