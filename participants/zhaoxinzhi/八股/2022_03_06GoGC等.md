## 一、写在前面

这一部分主要整理一下关于垃圾回收相关的知识点，以及GO语言中是如何进行垃圾回收的。

## 二、垃圾回收GC

> 其实对于GO语言的垃圾回收，对于面试来说，只需要理解：三色标记法，强弱不变性，stw，屏障。这几个概念就可以了。



### 1、都有哪些地方的变量需要GC管理？

> 堆中的对象需要GC管理。（即局部变量指针和New的对象）
>
> 全局变量放在初始化区，不需要。
>
> 栈中局部变量由操作系统管理。

栈中的变量不需要，因为栈里是随着函数结束会自己回收的，这个是归操作系统管理的（出栈自然回收）。

但是这句话反着说就不对了：函数里定义的变量，不一定在栈上，也可能在堆上，要看是否逃逸。

> 局部变量逃逸：比如函数里return局部变量指针。
>
> 关于逃逸：https://blog.csdn.net/xiaomiCJH/article/details/86478507

对于全局变量，既不定义在栈上，也不在堆上，而是在初始化区上。初始化区上的变量不需要回收。

> 初始化区分为已初始化区和未初始化区，bss是未初始化区。

结构体可以不用初始化，但结构体指针需要初始化（用new）

> 对于结构体，只有New或者直接用，没有用make的。

### 2、变量回收规则

1.全局变量不会被回收。

2.局部变量会被回收，也就是函数一旦运行完以后，函数内部的东西都会被销毁。

3.只要被另外一个作用域所引用就不会被回收 (闭包中引用的变量不会被回收)



### 3、垃圾回收算法：

#### 1、引用计数

对每一个对象都维护一个引用计数，当指针间赋值的时候，比如a=b，则b的计数+1，原a的计数-1.如果计数为0，则清理对象。

优点：1、实现简单，垃圾对象便于辨识。2、判定效率高，回收没有延迟性。

缺点：1、频繁更新引用计数降低性能。2、存在循环引用问题。

> 循环引用问题举例1：
>
> ```java
> public class MyObject {
>     public Object ref =null;
>     public static voi main(String[] args) {
>         MyObject myObject1 =new MyObject();
>         MyObject myObject2 =new MyObject();
>         myObject1.ref = myObject2;//至此，myObject2的引用数为2
>         myObject2.ref = myObject1;//至此，myObject1的引用数为2
>         myObject1 =null;//至此，myObject1的引用数为1
>         myObject2 =null;//至此，myObject2的引用数为1
>     }
> }
> //如果采用引用计数法,myObject1和myObject2将不能被回收,因为他们的引用计数无法为零。即失去了对两个对象空间的控制。
> //若要满足垃圾回收的条件,需要清除myObject2中的ref这个引用,而要清除掉这个引用的前提条件是myObject2引用的对象被回收,可是该对象的引用计数也为1,因为myObject1.ref指向了它。以此类推,也就进入一种死循环的状态。
> ```
>
> 循环引用问题举例2：
>
> 我们构造了一个列表对象（即ListNode类对象里有ListNode*，就跟力扣的链表题一样）,我们将最后一个元素的next属性指向第一个元素,即引用第一个元素,从而构成循环引用;这个时候如果我们将列表的头head赋值为null,此时列表的各个元素的计数器都不为0,同时我们也失去了对列表的引用控制,从而导致列表元素不能被回收!
>
> ![image-20220306213339500](D:\mystudy\internship\Cruel_Interview\participants\zhaoxinzhi\assets\2022_03_06GoGC等\image-20220306213339500.png)

python使用的就是引用计数的方法，并通过以下两种方式解决了循环引用问题。

1、手动解除：很好理解，就是在合适的时机，解除引用关系。

2、使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用问题。



#### 2、标记-清除（mark and sweep）

标记-清除（mark and sweep）分为两步，标记从根变量开始迭代得遍历所有被引用的对象，对能够通过应用遍历访问到的对象都进行标记为“被引用”；标记完成后进行清除操作，对没有标记过的内存进行回收。回收同时可能伴有碎片整理操作。

缺点：

1、可能产生内存碎片

2、STW（Stop-The-World）问题，每次垃圾回收的时候都会暂停所有的正常运行的代码，系统的响应能力会大大降低。

解决方式：各种 mark&swamp 变种（三色标记法），缓解性能问题。

#### 3、分代搜集

jvm 就使用的分代回收的思路。在面向对象编程语言中，绝大多数对象的生命周期都非常短。分代收集的基本思想是，将堆划分为两个或多个称为代（generation）的空间。新创建的对象存放在称为新生代（young generation）中（一般来说，新生代的大小会比 老年代小很多），随着垃圾回收的重复执行，生命周期较长的对象会被提升（promotion）到老年代中（这里用到了一个分类的思路，这个是也是科学思考的一个基本思路）。

优势：新生代垃圾回收和老年代垃圾回收两种不同的垃圾回收方式应运而生（先分类，之后再对症下药），分别用于对各自空间中的对象执行垃圾回收。新生代垃圾回收的速度非常快，比老年代快几个数量级，即使新生代垃圾回收的频率更高，执行效率也仍然比老年代垃圾回收强，这是因为大多数对象的生命周期都很短，根本无需提升到老年代。



### 4、GO的GC --- 三色标记法

> 参考链接：https://blog.csdn.net/xiaodaoge_it/article/details/121890145写的太好了图文并茂通俗易懂。
>
> Golang v1.3之前采用传统采取标记-清除法，需要STW，暂停整个程序的运行。
>
> 在v1.5版本中，引入了三色标记法和插入写屏障机制，其中插入写屏障机制只在堆内存中生效。但在标记过程中，最后需要对栈进行STW。
>
> 在v1.8版本中结合删除写屏障机制，推出了混合屏障机制，屏障限制只在堆内存中生效。避免了最后节点对栈进行STW的问题，提升了GC效率

#### 三色标记法流程

整个过程类似BFS：

- 步骤一：先把根节点加入队列中（这里根节点包括 **全局变量**和**每个goruntine中的执行栈**
- 步骤二：取出队列中所有节点并标记为黑色，把所有孩子节点到的都标记成灰色
- 步骤三：再次执行步骤二，直到队列为空。

此时未被标记的节点，或者说初始是白色的节点，就是要被回收的节点。

**注意，这种写法和普通的标记清除算法，都会用到STW啊？性能上有什么优化？**

#### 如何消除STW来提升性能

因为我们发现，如果在三色标记法中不使用STW，则会出现对象丢失的现象。（就跟普通的标记清除法一样）

而对象丢失，需要同时满足下面两个条件：

- 条件一：**白色对象被黑色对象引用**
- 条件二：**灰色对象与白色对象之间的可达关系遭到破坏**

因此只要把两个条件破坏掉一个，就可以在不使用STW的情况下保证对象不丢失。GoLang团队把破坏条件的方式分别叫做：**强三色不变式**和**弱三色不变式**。并根据这两种原则，对应提出了两种实现机制（也可以叫屏障保护机制）：**插入写屏障和删除写屏障**。

#### 强三色不变式

**规则**：不允许黑色对象引用白色对象

> 破坏了条件一： **白色对象被黑色对象引用**
>
> 解释：如果一个黑色对象不直接引用白色对象，那么就不会出现白色对象扫描不到，从而被当做垃圾回收掉的尴尬。

#### 插入写屏障

**规则**：当一个对象引用另外一个对象时，触发屏障保护，将另外一个对象标记为灰色。

> 满足了强三色不变式：不会存在黑色对象引用白色对象。

这里需要注意一点，插入屏障仅会在堆内存中生效，不对栈内存空间生效，这是因为go在并发运行时，大部分的操作都发生在栈上，函数调用会非常频繁。数十万goroutine的栈都进行屏障保护自然会有性能问题。（即 堆中的对象 引用 堆或栈中的对象，才会生效，==那栈中引用堆中的对象会生效吗？==）

由于栈上的对像没有插入写屏障机制，在扫描完成后，仍然可能存在栈上的白色对象被黑色对象引用，所以在最后需要对栈上的空间进行STW，然后对栈空间重新扫描（re-scan），防止对象误删除。

**缺点**：在一次正常的三色标记流程结束后，需要对栈上重新进行一次stw，然后再rescan一次。

#### 弱三色不变式

**规则**：黑色对象可以引用白色对象，但是白色对象的上游必须存在灰色对象

> 破坏了条件二：灰色对象与白色对象之间的可达关系遭到破坏
>
> 解释： 如果一个白色对象的上游有灰色对象，则这个白色对象一定可以扫描到，从而不被回收

#### **删除写屏障**

**规则**：在删除引用时，如果被删除引用的对象自身为灰色或者白色，触发删除写屏障，那么被标记为灰色。

**解释**：白色对象始终会被灰色对象保护

> 满足弱三色不变式。灰色对象到白色对象的路径不会断

**缺点**：一个对象的引用被删除后，即使没有其他存活的对象引用它（即天然没有条件一），它仍然会活到下一轮。如此一来，会产生很多的冗余扫描成本，且降低了回收精度。

> 举例：
>
> ![image-20220307232144864](D:\mystudy\internship\Cruel_Interview\participants\zhaoxinzhi\assets\2022_03_06GoGC等\image-20220307232144864.png)
>
> 

**小结：**

插入写屏障机制和删除写屏障机制中任一机制均可保护对象不被丢失。在V1.5的版本中采用的是插入写机制实现。

对比插入写屏障和删除写屏障：

插入写屏障：
插入写屏障哪里都好，就是栈上的操作管不到，所以最后需要对栈空间进行stw保护，然后rescan保证引用的白色对象存活。
删除写屏障：
在GC开始时，会扫描记录整个栈做快照，从而在删除操作时，可以拦截操作，将白色对象置为灰色对象。
回收精度低。

#### v1.8 混合写屏障机制

取其精华，去其糟泊。Golang团队，在v1.8版本结合了这两点，引入了混合写屏障机制。下面我们看下混合屏障机制的核心定义：

- GC刚开始的时候，会将栈上的可达对象全部标记为黑色。


- GC期间，任何在栈上新创建的对象，均为黑色。


> 上面两点只有一个目的，将栈上的可达对象全部标黑，最后无需对栈进行STW，就可以保证栈上的对象不会丢失。有人说，一直是黑色的对象，那么不就永远清除不掉了么，这里强调一下，标记为黑色的是可达对象，不可达的对象一直会是白色，直到最后被回收。

- 堆上被删除的对象标记为灰色

- 堆上新添加的对象标记为灰色

### 什么时候 go gc 性能会不好

1、内存泄露。

2、小对象太多

> 原因：小对象过多会导致GC三色法消耗过多的CPU。优化思路是减少对象分配。

​	如果是小对象用结构体比指针好。



### 从GC的角度，如何进行GO的性能优化

**1、减少对象分配** 

所谓减少对象的分配，实际上是尽量做到，对象的重用。 比如像如下的两个函数定义：

第一个函数没有形参，每次调用的时候返回一个 []byte，第二个函数在每次调用的时候，形参是一个 buf []byte 类型的对象，之后返回读入的 byte 的数目。

第一个函数在每次调用的时候都会分配一段空间，这会给 gc 造成额外的压力。第二个函数在每次迪调用的时候，会重用形参声明。

**2、老生常谈 string 与 []byte 转化** 

在 stirng 与 []byte 之间进行转换，会给 gc 造成压力 通过 gdb，可以先对比下两者的数据结构：

两者发生转换的时候，底层数据结结构会进行复制，因此导致 gc 效率会变低。解决策略上，一种方式是一直使用 []byte，特别是在数据传输方面，[]byte 中也包含着许多 string 会常用到的有效的操作。另一种是使用更为底层的操作直接进行转化，避免复制行为的发生。可以参考微信“雨痕学堂”中性能优化的第一部分，主要是使用 unsafe.Pointer 直接进行转化。

对于 unsafe 的使用，感觉可以单独整理一出一篇文章来了，先把相关资料列在这里 http://studygolang.com/articles/685 直观上，可以把 unsafe.Pointer 理解成 c++ 中的 void*，在 golang 中，相当于是各种类型的指针进行转化的桥梁。

关于 uintptr 的底层类型是 int，它可以装下指针所指的地址的值。它可以和 unsafe.Pointer 进行相互转化，主要的区别是，uintptr 可以参与指针运算，而 unsafe.Pointer 只能进行指针转化，不能进行指针运算。想要用 golang 进行指针运算，可以参考[这个](http://1234n.com/?post/rseosp)。具体指针运算的时候，要先转成 uintptr 的类型，才能进一步计算，比如偏移多少之类的。

**3、少量使用+连接 string**

由于采用 + 来进行 string 的连接会生成新的对象，降低 gc 的效率，好的方式是通过 append 函数来进行。

但是还有一个弊端，比如参考如下代码：

在使用了append操作之后，数组的空间由1024增长到了1312，所以如果能提前知道数组的长度的话，最好在最初分配空间的时候就做好空间规划操作，会增加一些代码管理的成本，同时也会降低gc的压力，提升代码的效率。



### 如何安全读写共享变量？

加Mutex锁，原子库，同步库，通道，context，sync.Map

