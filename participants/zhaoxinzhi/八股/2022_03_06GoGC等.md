## 一、写在前面

这一部分主要整理一下关于垃圾回收相关的知识点，以及GO语言中是如何进行垃圾回收的。

## 二、垃圾回收GC

> 其实对于GO语言的垃圾回收，对于面试来说，只需要理解：三色标记法，强弱不变性，stw，屏障。这几个概念就可以了。



### 1、都有哪些地方的变量需要GC管理？

> 堆中的对象需要GC管理。（即局部变量指针和New的对象）
>
> 全局变量放在初始化区，不需要。
>
> 栈中局部变量由操作系统管理。

栈中的变量不需要，因为栈里是随着函数结束会自己回收的，这个是归操作系统管理的（出栈自然回收）。

但是这句话反着说就不对了：函数里定义的变量，不一定在栈上，也可能在堆上，要看是否逃逸。

> 局部变量逃逸：比如函数里return局部变量指针。
>
> 关于逃逸：https://blog.csdn.net/xiaomiCJH/article/details/86478507

对于全局变量，既不定义在栈上，也不在堆上，而是在初始化区上。初始化区上的变量不需要回收。

> 初始化区分为已初始化区和未初始化区，bss是未初始化区。

结构体可以不用初始化，但结构体指针需要初始化（用new）

> 对于结构体，只有New或者直接用，没有用make的。

### 2、变量回收规则

1.全局变量不会被回收。

2.局部变量会被回收，也就是函数一旦运行完以后，函数内部的东西都会被销毁。

3.只要被另外一个作用域所引用就不会被回收 (闭包中引用的变量不会被回收)



### 3、垃圾回收算法：

#### 1、引用计数

对每一个对象都维护一个引用计数，当指针间赋值的时候，比如a=b，则b的计数+1，原a的计数-1.如果计数为0，则清理对象。

优点：1、实现简单，垃圾对象便于辨识。2、判定效率高，回收没有延迟性。

缺点：1、频繁更新引用计数降低性能。2、存在循环引用问题。

> 循环引用问题举例1：
>
> ```java
> public class MyObject {
>     public Object ref =null;
>     public static voi main(String[] args) {
>         MyObject myObject1 =new MyObject();
>         MyObject myObject2 =new MyObject();
>         myObject1.ref = myObject2;//至此，myObject2的引用数为2
>         myObject2.ref = myObject1;//至此，myObject1的引用数为2
>         myObject1 =null;//至此，myObject1的引用数为1
>         myObject2 =null;//至此，myObject2的引用数为1
>     }
> }
> //如果采用引用计数法,myObject1和myObject2将不能被回收,因为他们的引用计数无法为零。即失去了对两个对象空间的控制。
> //若要满足垃圾回收的条件,需要清除myObject2中的ref这个引用,而要清除掉这个引用的前提条件是myObject2引用的对象被回收,可是该对象的引用计数也为1,因为myObject1.ref指向了它。以此类推,也就进入一种死循环的状态。
> ```
>
> 循环引用问题举例2：
>
> 我们构造了一个列表对象（即ListNode类对象里有ListNode*，就跟力扣的链表题一样）,我们将最后一个元素的next属性指向第一个元素,即引用第一个元素,从而构成循环引用;这个时候如果我们将列表的头head赋值为null,此时列表的各个元素的计数器都不为0,同时我们也失去了对列表的引用控制,从而导致列表元素不能被回收!
>
> ![image-20220306213339500](D:\mystudy\internship\Cruel_Interview\participants\zhaoxinzhi\assets\2022_03_06GoGC等\image-20220306213339500.png)

python使用的就是引用计数的方法，并通过以下两种方式解决了循环引用问题。

1、手动解除：很好理解，就是在合适的时机，解除引用关系。

2、使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用问题。



#### 2、标记-清除（mark and sweep）

标记-清除（mark and sweep）分为两步，标记从根变量开始迭代得遍历所有被引用的对象，对能够通过应用遍历访问到的对象都进行标记为“被引用”；标记完成后进行清除操作，对没有标记过的内存进行回收。回收同时可能伴有碎片整理操作。

缺点：

1、可能产生内存碎片

2、STW（Stop-The-World）问题，每次垃圾回收的时候都会暂停所有的正常运行的代码，系统的响应能力会大大降低。

解决方式：各种 mark&swamp 变种（三色标记法），缓解性能问题。

#### 3、分代搜集

jvm 就使用的分代回收的思路。在面向对象编程语言中，绝大多数对象的生命周期都非常短。分代收集的基本思想是，将堆划分为两个或多个称为代（generation）的空间。新创建的对象存放在称为新生代（young generation）中（一般来说，新生代的大小会比 老年代小很多），随着垃圾回收的重复执行，生命周期较长的对象会被提升（promotion）到老年代中（这里用到了一个分类的思路，这个是也是科学思考的一个基本思路）。

优势：新生代垃圾回收和老年代垃圾回收两种不同的垃圾回收方式应运而生（先分类，之后再对症下药），分别用于对各自空间中的对象执行垃圾回收。新生代垃圾回收的速度非常快，比老年代快几个数量级，即使新生代垃圾回收的频率更高，执行效率也仍然比老年代垃圾回收强，这是因为大多数对象的生命周期都很短，根本无需提升到老年代。



### 什么时候 go gc 性能会不好

1、内存泄露。

2、小对象太多

> 原因：小对象过多会导致GC三色法消耗过多的CPU。优化思路是减少对象分配。

​	如果是小对象用结构体比指针好。





### 如何安全读写共享变量？

加Mutex锁，原子库，同步库，通道，context，sync.Map

