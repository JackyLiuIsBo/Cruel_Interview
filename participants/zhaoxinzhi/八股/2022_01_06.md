## 一、写在前面

下一步的计划打算用五天时间复习一遍**操作系统**，我打算不只是背知识点，而是在背的同时扩展自己的知识面，同时多敲敲代码帮助自己理解

## 二、操作系统

### 1、阻塞非阻塞，同步与异步

> 经典例子
>
> 老张爱喝茶，废话不说，煮开水。 出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。 1 老张把水壶放到火上，立等水开。（同步阻塞） 老张觉得自己有点傻 2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞） 老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。 3 老张把响水壶放到火上，立等水开。（异步阻塞） 老张觉得这样傻等意义不大 4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞） 老张觉得自己聪明了。
>
> 所谓同步异步，只是对于水壶而言。 普通水壶，同步；响水壶，异步。 虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。 同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。
>
> 所谓阻塞非阻塞，仅仅对于老张而言。 立等的老张，阻塞；看电视的老张，非阻塞。 情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。



### 2、五种IO模型

UNIX有5种I/O模型,阻塞会发生在两个阶段上:

1.阻塞式I/O 等待数据时阻塞 数据从内核复制到用户空间时阻塞 

2.非阻塞式I/O 等待数据不阻塞,但是轮询会占用cpu资源 数据从内核复制到用户空间时阻塞 

3.I/O复用 考虑到轮询占用cpu资源的问题,阻塞在选择器上,减轻处理器负担 将数据从内核复制到用户空间时阻塞

4.信号驱动式I/O 等待数据不阻塞,数据准备好时通知接收数据,将数据从内核复制到用户空间时阻塞

以上四种或多或少均有阻塞现象存在,它们都是同步I/O模型

5.异步I/O 等待数据时不阻塞 将数据从内核复制到用户空间时也不阻塞. 数据到了用户空间以后才发信号,就像你在网上下了订单,快递员拿着你的快件站在你家门口才通知你开门签收的样子.

在网上下了订单,货物到了离你家最近的自提点,商城通知你去自提点取提货.你专门抽出时间去提货.这是4.信号驱动式I/O.因为在来回自提点的路上你其实是阻塞的.

### 3、进程与线程的区别

> 1、定义	2、地址空间	3、依赖性与崩溃	4、拥有资源	5、切换开销	6、间通信	

- 进程（Process）是系统进行资源分配和调度的基本单位，线程（Thread）是CPU调度和分派的基本单位；
- 进程有自己的独立地址空间，线程共享所属进程的地址空间；
- 线程依赖于进程而存在，一个进程至少有一个线程；
- 进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，和其他线程共享本进程的相关资源如内存、I/O、cpu等；
- 在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销远大于线程切换的开销；
- 线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行；
- 多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮

### 4、进程间通信IPC有哪些方式？

> python进程间通信：https://www.cnblogs.com/guguobao/p/9398653.html

- 无名管道
  - 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据；只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程)
  
- 有名管道

  > python的实现方式：https://blog.csdn.net/claroja/article/details/103489937

- 消息队列

  - 消息队列是消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

- 信号(Signal)

  - 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生

- 共享内存

  - 共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。**共享内存是最快的 IPC 方式**，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。

- 信号量(Semaphore)：初始化操作、P操作、V操作；P操作：信号量-1，检测是否小于0，小于则进程进入阻塞状态；V操作：信号量+1，若小于等于0，则从队列中唤醒一个等待的进程进入就绪态

- 套接字(Socket)

  - 套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。

### 5、线程间通信有哪些方式？

线程间的通信目的主要是用于**线程同步**，所以线程没有像进程通信中的用于数据交换的通信机制。

- 信号机制(Signal)：类似进程间的信号处理
- 全局变量（需要通过锁机制来控制互斥访问）
  - 锁机制：包括互斥锁、条件变量、读写锁
  - 互斥锁提供了以排他方式防止数据结构被并发修改的方法。
  - 读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
  - 条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
- 信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量

### 6、并发、并行、异步

并发：**在一个时间段中同时有多个程序在运行，是一个宏观的概念**。但其实任一时刻，只有一个程序在CPU上运行，**宏观上的并发是通过不断的切换实现的，多线程就是并发运行的一段代码**。

并行（和串行相比）：在多CPU系统中，多个程序无论宏观还是微观上都是同时执行的。

异步（和同步相比）：同步是顺序执行，异步是在等待某个资源的时候继续做自己的事。**多线程是实现异步的手段。**

### 7、僵尸进程与孤儿进程的区别（待进一步整理）

一个子进程结束后，它的父进程并没有等待它（调用wait或者waitpid），那么这个子进程将成为一个僵尸进程。僵尸进程是一个已经死亡的进程，但是并没有真正被销毁。它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程表中保留一个位置，记载该进程的进程ID、终止状态以及资源利用信息(CPU时间，内存使用量等等)供父进程收集，除此之外，僵尸进程不再占有任何内存空间。这个僵尸进程可能会一直留在系统中直到系统重启。

一个父进程已经结束了，但是它的子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程会被Init（进程ID为1）接管，当这些孤儿进程结束时由Init完成状态收集工作。

,liunx *系统*中,*僵尸进程*并不*占用资源*。只是它对应的PCB(Process Control Block)还存在。
