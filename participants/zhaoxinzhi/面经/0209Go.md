## 一、写在前面

这是一篇字节GoLang面经。

> 链接：https://www.nowcoder.com/discuss/733900

## 二、题目

### 1、为什么要使用gRPC

gRPC的明显优势是它使用了一种高效的二进制编码，这使得它比JSON/HTTP更快。虽然速度更快总是受欢迎的，但是有两个方面对我们来说更重要：清晰的接口规范和对流的支持。

使用gRPC的动机:简单而高效的通信，我们希望通信高效,快速且轻巧。

### 2、gRPC为什么高效

> 参考链接：https://zhuanlan.zhihu.com/p/148139089

- 它基于HTTP2构建，既支持传统的请求-响应模型，也支持双向流模型。
- 可以将JSON数据转换到协议缓冲区
- 多路复用
- 双向流模型
- 网络传输的是二进制数据，相对于JSON等文本数据更加轻量级。
- 多语言支持
- *gRPC*客户端和服务端可以实现批量操作优化,客户端可以攒一些请求,一口气发给服务端,服务端也可以批量返回结果,借此实现流式rpc。

### 3、聊一下HTTP1.0/1.1/2.0/3.0

> 详细区别看：https://zhuanlan.zhihu.com/p/342311013

- HTTP1.0
  - 请求与响应支持 HTTP 头，响应含状态行，增加了状态码，
  - 支持 HEAD，POST 方法
  - 支持传输 HTML 文件以外其他类型的内容
  - HTTP1.0 使用的是非持久连接，主要缺点是**客户端必须为每一个待请求的对象建立并维护一个新的连接**

- HTTP1.1

  - 支持长连接。
  - 在HTTP1.0的基础上引入了更多的缓存控制策略。
  - 引入了请求范围设置，优化了带宽。
  - 在错误通知管理中新增了错误状态响应码。
  - 增加了Host头处理，可以传递主机名（hostname）。（在此之前，就是一个ip对应一个域名，现在一个ip可以多个域名了）

- HTTP2.0

  - 二进制分帧
    - 在HTTP和TCP之间引入二进制分帧层，来实现多路复用。
    - 引入“流”的概念，流是连接中的一个虚拟信道，可以承载双向消息传输。每个流有唯一整数标识符。客奇服偶。
  - 多路复用
    - 解决了HTTP1.x的队首阻塞的问题，一个通过一个TCP连接，就可以**并行同时**发送多个请求和响应
  - 给请求设置优先级
    - 服务器会优先处理优先级高的请求。优先级在int范围内，0的优先级最高。
  - 首部压缩
    - HTTP1.x每一次通信(请求或响应)都会携带首部信息用于描述资源属性。HTTP2.0使用“首部表”来跟踪和存储之前通信用的键值对，“首部表”在连接过程中始终存在。因此不需要每次通信都携带首部。
  - 服务端推送

  

> 关于HTTP2的新特征：https://www.zhihu.com/question/444343281/answer/2161521918
>
> HTTP1.1为什么不能多路复用？
>
> 1.1不能多路复用的本质是不能准确把无序的响应一个个分离开来并一一对应。http1.1 的pipe模式没有被广泛应用也就是这个原因。

### 4、什么是幂等性

> GET DELETE PUT 都是幂等的，POST不是幂等的

在HTTP/1.1规范中幂等性的定义：HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。（指对服务器有一样的作用，而与返回结果是否相同无关）

幂等性属于语义范畴，正如编译器只能帮助检查语法错误一样，HTTP规范也没有办法通过消息格式等语法手段来定义它，这可能是它不太受到重视的原因之一。但实际上，幂等性是分布式系统设计中十分重要的概念，而HTTP的分布式本质也决定了它在HTTP中具有重要地位。

HTTP GET方法用于获取资源，不应有副作用，所以是幂等的。比如：`GET http://www.bank.com/account/123456`，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。`GET http://www.news.com/latest-news`这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。

HTTP DELETE方法用于删除资源，有副作用，但它应该满足幂等性。比如：`DELETE http://www.forum.com/article/4231`，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。

比较容易混淆的是HTTP POST和PUT。POST和PUT的区别容易被简单地误认为“POST表示创建资源，PUT表示更新资源”；而实际上，二者均可用于创建资源，更为本质的差别是在幂等性方面。

>POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：`POST http://www.forum.com/articles`的语义是在`http://www.forum.com/articles`下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。而PUT所对应的URI是要创建或更新的资源本身。比如：`PUT http://www.forum/articles/4231`的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。
>
>在介绍了几种操作的语义和幂等性之后，我们来看看如何通过Web API的形式实现前面所提到的取款功能。很简单，用POST /tickets来实现create_ticket；用PUT /accounts/account_id/ticket_id?amount=xxx来实现idempotent_withdraw。值得注意的是严格来讲amount参数不应该作为URI的一部分，真正的URI应该是/accounts/account_id/ticket_id，而amount应该放在请求的body中。这种模式可以应用于很多场合，比如：论坛网站中防止意外的重复发帖。



### 5、为什么HTTP协议是无状态的？

> 一句话，每个请求之间需要使用到状态机的就是有状态的，不需要使用的就是无状态的。
>
> 何时需要使用状态机？举个最简单的例子，对于不同状态，能接受的指令是不同的，这就需要状态之间转化等逻辑，因此需要状态机。

无状态指的是任意一个Web请求必须完全与其他请求隔离,当请求端提出请求时,请求本身包含了相应端为相应这一请求所需的全部信息。即上一次的请求对这次的请求没有任何影响。

简单的说就是cookie和session起到保存客户端状态的作用,但是它们并没有改变*http*协议本身这种*无状态的*性质,可以理解为在应用上做了状态保留。



> 举个有状态协议的例子：
>
> 常见的许多七层协议实际上是有状态的，例如SMTP协议，它的第一条消息必须是HELO，用来握手，在HELO发送之前其他任何命令都是不能发送的；接下来一般要进行AUTH阶段，用来验证用户名和密码；接下来可以发送邮件数据；最后，通过QUIT命令退出。可以看到，在整个传输层上，通信的双方是必须要时刻记住当前连接的状态的，**因为不同的状态下能接受的命令是不同的**；另外，之前的命令传输的某些数据也必须要记住，可能会对后面的命令产生影响。这种就叫做有状态的协议。
>
> 
>
> 相反，为什么说HTTP是无状态的协议呢？因为**它的每个请求都是完全独立的**，每个请求包含了处理这个请求所需的完整的数据，发送请求不涉及到状态变更。即使在HTTP/1.1上，同一个连接允许传输多个HTTP请求的情况下，如果第一个请求出错了，后面的请求一般也能够继续处理（当然，如果导致协议解析失败、消息分片错误之类的自然是要除外的）可以看出，这种协议的结构是要比有状态的协议更简单的，一般来说实现起来也更简单，**不需要使用状态机**，一个循环就行了。

### 6、简要介绍下HTTP格式？

HTTP请求报文由3部分组成（请求行+请求头+请求体）

1、请求行：请求方法(GET)+请求对应的URL地址(/chapter12/index.html)+协议名称及版本号(HTTP/1.1)

注意，请求对应的URL地址，和报文头的Host属性组成完整的请求URL。

2、请求头：是HTTP的报文头，报文头包含若干个属性，格式为“属性名:属性值”，服务端据此获取客户端的信息。

3、请求体就不说了。GET的在url中，POST的在请求体中。

### 7、HTTP的CA证书工作原理

### 8、关于TCP粘包现象

首先这是在传输层，因为Nagle算法或者其他原因，可能我客户端连续发了两个TCP包，在服务端还没来得及read第一个TCP报文的时候，第二个报文也到了。又因为TCP是基于字节流的传输，所以需要在应用层（或者说服务端程序中）来区分第一个TCP报文的结尾字节在哪里。

在HTTP协议这个应用层协议中，是在header中通过Context-length字段来解决这个问题的。

如果项目中，我们不得不直接使用TCP这种传输层协议的话，也是需要协商好粘包问题的解决方式。

**具体如何解决呢？**

可以像HTTP一样加长度字段来告诉服务端。

或者服务端必须处理完第一个请求，才可以处理第二个请求（像HTTP0.9一样，HTTP0.9没有Header所以没有Context-length字段，所以他不支持一个连接发送多个请求，因为一个连接处理一个请求就不需要解决这个问题了）



### 9、关于字符流和字节流



### 10、对称加密和非对称加密

> Q1：概念是什么？
>
> Q2：非对称加密慢怎么解决？
>
> A2：可以采用混合加密。即先用非对称加密 来传输会话密钥，再用对称加密进行通信。

### 11、怎么在指定的路径里找所有文本文件中带有“abc”的内容

考察Linux命令。`awk`。

### 12、考察数据库

> Q1：MySQL事务的ACID
>
> Q2：MySQL原子性和持久性怎么保证
>
> > https://blog.51cto.com/jack88/2524357
>
> mysql原子性的保证是利用了undo log。mysql持久性的保证是利用了redo log。
>
> Q3：redolog工作原理
>
> Q4：宕机恢复
>
> Q5：undolog在宕机时怎么保证原子性

### 13、线程什么是私有的，什么是共有的

**私有的：**

1. 栈（局部变量，函数的参数）。
2. 线程局部存储（Thread Local Storage，TLS），有限的容量。
3. 寄存器 （执行流的基本数据）。

**公有的：**

1. 全局变量。
2. 堆上的数据。
3. 函数里的静态变量。
4. 程序代码，任何线程都有权利读取并执行任何代码。
5. 打开文件，A 线程打开的文件可以由 B 线程读写。

#### 14、场景设计题

有100G的文本文件，我要解析出这些文本中包含的URL并统计出来，取出其中的Top10，要求用并发编程加速。

解答：

并发读取到内存中（并发数为io延迟时间除以逻辑处理时间），并且把url按最后一位hash到本地文件中。然后再并发读取这些本地文件，用map维护每个url的出现次数，并且在每个本地文件处理完后就把对应的map值更新到大小为10的堆中，最后堆中元素就是答案。

但是有几个细节我不太明白，
1、首先并发读取到内存中的时候，是不是得控制goruntine的个数？不然内存应该也不够用的吧。
2、其次这个map是全局共享吗？还是一个goruntine一个map呢？不管哪种方式是不是都得考虑内存不够的情况。
3、最后维护这个堆，应该得保证是线程安全的吧，如何保证呢？直接对这个资源加锁吗？还是有粒度更小的方式？