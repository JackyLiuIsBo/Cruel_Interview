## 一、写在前面

- [ ] ​	字节跳动后端开发校招。（这应该是个Java转Go的选手）

> 参考链接：https://www.nowcoder.com/discuss/836630

## 二、GoLang

### 1、考察数据库

- MYSQL的隔离级别

  - 太简单不整理了

- （我的扩展）什么是幻读

  - 幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。
  - 在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。
  - 幻读仅专指“新插入的行”。

- 如何解决幻读

  - MVCC+Next-key lock（即同时添加间隙锁与行锁）
  - 具体来说，使用查询的时候使用`select...for update`而不是`select`

- 间隙锁的作用

  - 保证某个间隙内的数据在锁定情况下不会发生任何变化。
  - 间隙锁锁的是索引叶子节点的next指针。
  - 间隙锁只有在InnoDB的可重复度隔离级别下生效。

- （我的扩展）使用间隙锁可能产生的问题

  - 可能造成死锁，因为间隙锁之间不会冲突。所以A和B两个事务可以都获取(5,10]的间隙锁，然后insert的时候A等B释放，B等A释放，就死锁了。

- （我的扩展）间隙锁导致的死锁的解决办法

  > 间隙锁这一类问题看：https://blog.csdn.net/h2604396739/article/details/86518943
  >
  > 现在水平有限实在是啃不动了。

  - 因为间隙锁是在可重复读隔离级别下才会生效，所以把隔离级别设置为读提交的话，就没有间隙锁了。但同时，你要解决可能出现的数据和日志不一致问题，需要把 binlog 格式设置为 row。这，也是现在不少公司使用的配置组合。

- MVCC的作用

  - 多版本并发控制，是InnoDB实现隔离级别的一种方式，用于实现**读已提交**和**可重复读**两种隔离级别
  - 实现了多个事务并发下，读操作的非阻塞
  - Innodb的MVCC能防止幻读的发生。(不是每个MVCC都可以，看MVCC怎么实现)

- 快照读和当前读的关系

  - `select`是快照读：当前事务对应版本的数据。（可重复读级别下，不会看到别的事务插入的数据）
  - `select…lock in share mode`,`select…for update`,`update,delete,insert`是当前读：读取的都是最新版本的数据。

- （我的扩展）MVCC的原理

  - 场景：MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容，因为READ UNCOMMITTED总是读取最新的数据行，而不是符合当前事务版本的数据。行，而SERIALIZABLE会对所有读取到的行都加锁。
  - 原理：MVCC保存了某一时刻数据的一个快照。意思就是无论事物运行了多久，它们都能看到一致的数据。也就是说在相同的时间下，不同的事物看相同表的数据是不同的。
  - 底层原理：通过在每行记录后面保存两个隐藏的列来实现。这两个列，一个保存了行的创建时间，一个保存了行的过期时间(删除时间)。并且存储的并不是真实的时间值，而是系统版本号(system version number)。每开始一个新的事务，系统版本号都会自动递增。开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

- MySQL索引的建立注意的问题

- 建立联合索引的问题

- 最左匹配原则

- 数据稀疏度对索引效率的影响

### 2、计算机网络原理

- TCP和UDP的区别

- Time_wait的作用

  - Time_wait就是tcp释放连接的四次挥手后的主动关闭连接方的状态。
  - 可靠地实现TCP全双工连接的终止

  > Time_wait：
  >
  > 主动关闭的Socket端会进入TIME_WAIT状态，并且持续2MSL时间长度（大概4min），MSL就是maximum segment lifetime(报文段最大生存时间，官方建议是2min），这是一个IP数据包能在互联网上生存的最长时间，超过这个时间将在网络中消失。

- （我的扩展）为什么要设置Time_wait？

  > 参考链接：https://zhuanlan.zhihu.com/p/51961509
  >
  > 一句话总结：1.为实现TCP全双工连接的可靠释放，2.为使旧的数据包在网络因过期而消失。

  - 原因一：为了保证客户端发送的最后一个ack报文段能够到达服务器。

    > 万一丢失，则服务端重传第三次挥手的FIN信息报，客户端再重传第四次挥手的ACK。如果没有这2msl，客户端发送完最后一个ack数据报后直接关闭连接，那么就接收不到服务器超时重传的fin信息报(**此处应该是客户端收到一个非法的报文段，而返回一个RST的数据报，表明拒绝此次通信，然后双方就产生异常，而不是收不到。**)，那么服务器就不能按正常步骤进入close状态。那么就会耗费服务器的资源。当网络中存在大量的timewait状态，那么服务器的压力可想而知。

  - 原因二：经过2msl的时间让本次连接产生的所有报文段都从网络中消失，保证新的连接中不会出现旧连接的报文段。

    > 即防止在新的连接中出现已经失效的连接请求报文段。
    >
    > 旧 TCP 连接的被动关闭一方，由于没有收到第四次挥手报文，超时重发 FIN 报文。但此时主动打开的一方已经关闭连接，上一个连接的端口已经被用于建立新的 TCP 连接中，这样会莫名其妙收到一个 FIN 报文，产生混乱。

- （我的扩展）如果Time_wait过多会带来什么问题？

  > 参考链接：https://blog.csdn.net/weixin_41850404/article/details/84749771

  - 在高并发短连接的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发请求量持续很高，此时部分客户端就会显示连接不上服务器。因为端口不够用了。大部分端口都在timewait中。
  - 

### 3、Java相关

ThreadLocal使用场景和问题

双亲委派模型的介绍，破坏的情景

Spring的bean和双亲委派





-----------



## 三、二面

 系统设计：如何设计一个爬虫，Selenium框架的优缺点 

 Redis常见数据结构 

 Redis的跳表结构，构建调表的源代码分析 

 为什么Redis快 

 Redis除了缓存还能够做什么 

 系统设计：如何设计一个延迟队列 

 如何理解Map Reduce 

 Flink框架里面有几种窗口 

 系统设计：Flink设计一个统计重复id的系统 

 布隆过滤器的原理

---------------



## 四、三面

操作系统的缺页中断概念

数据库的B+树为什么不使用红黑树

大数据的topN问题

page fault流程

中断内发生了什么事

乐观锁的概念

CAS原子性如何保证,ABA问题如何解决

