## 一、写在前面

- [x] 这是一篇字节GoLang面经。

>字节成都抖音后端，链接：https://www.nowcoder.com/discuss/714851

## 二、GoLang

### 1、数据库

> Q1：给了两个事务，分析在不确定事务语句的执行顺序的情况下，在四种不同隔离级别最终的结果是否一致
>
> Q2：mvcc 和 read view
>
> **MVCC基本思想：**
>
> - MVCC是乐观锁的一种实现，是通过保存数据在某一个时间点的快照实现的，写操作更新最新的版本，读操作读取旧版本；
> - MVCC中事务的**修改操作**（增删改）会为行记录**新增一个版本快照**，并把当前事务id写入trx_id；
> - MVCC是InnoDB实现隔离级别的一种方式，用于实现**读已提交**和**可重复读**两种隔离级别；
>   - 对于**读未提交**，直接读取最新版本的数据；
>   - 对于**串行化**，使用加锁的方式访问记录；
> - 大多数事务型存储引擎实现都不是简单的行锁，基于并发性的考虑，一般会同时实现多版本并发控制（MVCC）处理读写冲突；
> - 
>
> **系统版本号sys_id：每开始一个新的事务，系统版本号递增；**
>
> - 在InnoDB中，聚簇索引记录中包含两个**隐藏列**：
>
> - - trx_id：对记录进行改动时，trx_id会记录当前事务id，也就是当前系统版本号；
>   - roll_pointer：对记录进行改动，会把旧版本记录写入undo日志，roll_pointer指向修改之前的版本；
>
> - 对同一条记录的更新，会把旧值放到一条undo日志中，作为一个旧版本的记录，多次更新之后这些版本会被roll_pointer连接成一个链表，称之为**版本链**；
>
> **版本读取：**
>
> - 对于**读取已提交**和**可重复读**，就会用到版本链，关键在于怎么判断版本链中哪个版本对当前事务可见；
> - 使用ReadView（快照），ReadView是一个包含当前已经开始但是没有提交的事务的列表，记录每个事务的事务id，记最小事务id为min_id，最大事务id为max_id；

关于MVCC（Multi-Version Concurrency Control，多版本并发控制），MySQL中针对**读已提交**和**可重复读**两个隔离级别进行设计。

在可重复读隔离级别中：

- ReadView是以一个事务的开始和结束作为它的生命周期的。即事务的开始创建RV，事务的结束销毁RV。

在读已提交隔离级别中：

- ReadView是以一个事务的开始和结束作为它的生命周期的。即事务的开始创建RV，事务的结束销毁RV。
- ReadView在每一次读取数据的时候被创建。其中`creator_trx_id`等字段不变，只是`m_ids`更新成当前的。
- 

ReadView包含四个字段
m_ids:表示活跃事务id列表
min_trx_id:活跃事务中的最小事务id
max_trx_id:已创建的最大事务id
creator_trx_id:当前的事务id
对当前事务来说，按照以下规则从最新的版本开始遍历，获取对应的版本记录。

```
具体策略如下：
被访问的trx_id与readview中的creator_trx_id相同，表示当前事务在访问自己修改的记录，可见，返回；
被访问的trx_id小于min_trx_id，表明该版本已提交，可见，返回；
被访问的trx_id大于等于max_trx_id，表明该版本在生成readview时，还未开启，不可见，返回；
被访问的trx_id在min_trx_id和max_trx_id之间，判断是否在m_ids中，如果在，则说明生成readview时，该版本事务未提交，该版本不可见；如果不在，则说明生成readview时，该版本事务已提交可见，返回。

如果当前记录版本不可读，就根据回滚指针roll_pointer找到旧版本的记录再进行判断；
对于读取已提交，每次查询都会生成一个新的ReadView；
对于可重复度，一个事务在第一次SELECT的时候生成一个ReadView，之后的查询复用这个ReadView；
```





### 2、暂时不会的

1. 怎么做的连接复用，怎么支持的并发请求，go的netpoll是怎么实现的像阻塞read一样去使用底层的非阻塞read
2. 一致性hash怎么实现的，让我写代码把整个过程简单介绍下
3. 设计消息队列应该考虑些什么问题，消息持久化的文件存储格式应该怎么设计

