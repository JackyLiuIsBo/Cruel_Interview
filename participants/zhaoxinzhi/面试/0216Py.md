## 一、写在前面

这是字节后端实习的Python面经。（实习）

> 链接：https://www.nowcoder.com/discuss/359048
>
> 我是被捞起来面的，一面1个小时，休息了5分钟之后直接二面，也是1个小时。第二天三面，应该是leader面，就面了半小时左右。过了两天之后进入HR面。



## 二、Go

### 1、计算机网络

- 三次握手 

- （我的拓展）可以两次握手吗？

  - 不可以。两个原因。
  - 可能会出现已失效的连接请求报文段又传到了服务器端
  - 无法保证第二次握手被正确接收，也无法保证Client和Server之间成功互换初始序列号。

- 握手时产生的序列号干什么用的

  - 用来标识每一个包
  - seq是保证重传、窗口大小调整等的前提

- （我的拓展）如果没有这个序列号会发生什么？

  > 参考链接：https://www.zhihu.com/question/21033999

  - 没有序列号机制的话，就没法区分一个连接中的不同的包了
  - 会出现包丢失和包重复的现象，而服务端无法察觉。
  - 如果不携带序列号，就可以很轻易的伪造TCP链接（刷票啥的不怕被封ip了）

- 讲一下接收窗口

  - 防止发送方发送速率太快，接收方缓存区不够导致溢出。接收方会维护一个接收窗口 receiver window（窗口大小单位是字节），接受窗口的大小是根据自己的资源情况动态调整的，在返回ACK时将接受窗口大小放在TCP报文中的窗口字段告知发送方。发送窗口的大小不能超过接受窗口的大小，只有当发送方发送并收到确认之后，才能将发送窗口右移。

- （我的拓展）什么是零窗口？

  - 如果接收方没有能力接收数据，就会将接收窗口设置为0，这时发送方必须暂停发送数据，但是会启动一个持续计时器(persistence timer)，到期后发送一个大小为1字节的探测数据包，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送。

- TCP和UDP的本质区别

  - 是否面向连接
  - 是否提供可靠传输
  - 面向字节流Vs面向报文

- 什么时候选择TCP/UDP

  - 对某些实时性要求比较高的情况，选择UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失

- HTTPS的连接过程

- 7层模型和4层模型，每一层有哪些常见协议？ 

- 路由器/交换机是哪一层 

- 网络层用来干嘛？传输层用来干嘛？ 

- HTTP可以使用UDP吗 

  - HTTP不可以使用UDP，主要是HTTP需要基于可靠的传输协议，而UDP不可靠。但是HTTP3.0是使用udp实现的。

- HTTPS怎么确认收到的包就是服务器发来的 

  - https对端口和ip不加密，建立通信之后，后续的包就知道是服务器发来的了。

- 确定发送窗口的大小，如何最大利用带宽，假设延迟100ms，发送端10Mb/s，接收端100Mb/s

  - 首先，通信的瓶颈在于1.带宽 2.发送窗口。这里的意思是带宽不构成阻碍
  - 答案是1Mb，因为发送端在收到第一个ack前，发送了0.1乘10Mb数据。发送窗口必须大于等于这个值，不然发送窗口会导致带宽不能被充分利用

- 输入 `www.baidu.com`，怎么变成`https://www.baidu.com` 的，怎么确定用HTTP还是HTTPS

  - 一种是原始的302跳转，服务器把所有的HTTP流量跳转到HTTPS。但这样有一个漏洞，就是中间人可能在第一次访问站点的时候就劫持。
    解决方法是引入HSTS机制，用户浏览器在访问站点的时候强制使用HTTPS。
    详情见https://www.sohu.com/a/136637876_487516

- TCP的流量控制和拥塞控制

- 浏览器中输入网址到获得页面的全过程

### 2、数据库

- 事务的四大特性
- 四种隔离级别
- 什么是幻读
- InnoDB 怎么防止幻读
- B+树原理，为什么使用B+而不是二叉平衡树

### 3、操作系统

- 用户态如何切换到内核态
- 进程间通信的方式，哪种最快
- 信号量怎么实现对共享资源的访问

### 4、语言

- 什么是Python生成器，迭代器
- 什么是装饰器；
- 元组和list的区别；
  - 列表是动态的，其大小可以改变。元组是不可变的，一旦创建就不能修改。
  - 在C的实现是相似的，二者速度差不多。对于小对象来说，tuple会有一个对象池，所以小的、重复的使用tuple还有益处的。
- Python中的dict底层怎么实现的
  - hashtable，用开放定址法。因为追求效率，牺牲内存。以空间换时间。
- list的底层怎么实现的；
  - 不是链表，而是采用分离式技术实现的可变长数组。（其实就是变量存的是地址的vector，美其名曰分离式技术而已。正因为这种元素外置的方式，所以元素可以是任意类型）
- 双等于和is有什么区别
  - 比如对于两个list，==比较的是值是否相同（即调用`__eq__()`方法），is是比较两个对象的地址（即二者是否是同一个实例对象）
- Python多线程用了几个CPU
  - 一个

### 5、聊天

和其他同学相比，你觉得自己有什么优势
自己的不足有哪些
GitHub和博客上分享过哪些东西

你用Django的时候，觉得它有哪些好的特性

